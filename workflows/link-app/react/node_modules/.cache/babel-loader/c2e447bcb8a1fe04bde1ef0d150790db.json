{"ast":null,"code":"\"use strict\";\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\n  result[\"default\"] = mod;\n  return result;\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nvar secp256k1 = __importStar(require(\"secp256k1\"));\nfunction privateKeyVerify(privateKey) {\n  return secp256k1.privateKeyVerify(privateKey);\n}\nexports.privateKeyVerify = privateKeyVerify;\nfunction publicKeyCreate(privateKey, compressed) {\n  if (compressed === void 0) {\n    compressed = true;\n  }\n  return Buffer.from(secp256k1.publicKeyCreate(privateKey, compressed));\n}\nexports.publicKeyCreate = publicKeyCreate;\nfunction publicKeyVerify(publicKey) {\n  return secp256k1.publicKeyVerify(publicKey);\n}\nexports.publicKeyVerify = publicKeyVerify;\nfunction publicKeyConvert(publicKey, compressed) {\n  if (compressed === void 0) {\n    compressed = true;\n  }\n  return Buffer.from(secp256k1.publicKeyConvert(publicKey, compressed));\n}\nexports.publicKeyConvert = publicKeyConvert;\nfunction privateKeyTweakAdd(publicKey, tweak) {\n  return Buffer.from(secp256k1.privateKeyTweakAdd(Buffer.from(publicKey), tweak));\n}\nexports.privateKeyTweakAdd = privateKeyTweakAdd;\nfunction publicKeyTweakAdd(publicKey, tweak, compressed) {\n  if (compressed === void 0) {\n    compressed = true;\n  }\n  return Buffer.from(secp256k1.publicKeyTweakAdd(Buffer.from(publicKey), tweak, compressed));\n}\nexports.publicKeyTweakAdd = publicKeyTweakAdd;\nfunction sign(message, privateKey) {\n  var ret = secp256k1.ecdsaSign(message, privateKey);\n  return {\n    signature: Buffer.from(ret.signature),\n    recovery: ret.recid\n  };\n}\nexports.sign = sign;\nfunction verify(message, signature, publicKey) {\n  return secp256k1.ecdsaVerify(signature, message, publicKey);\n}\nexports.verify = verify;","map":{"version":3,"sources":["../src/shims/hdkey-secp256k1v3.ts"],"names":[],"mappings":";;;;;;;;;;;;AAAA,IAAA,SAAA,GAAA,YAAA,CAAA,OAAA,CAAA,WAAA,CAAA,CAAA;AAEA,SAAgB,gBAAgB,CAAC,UAAkB,EAAA;EACjD,OAAO,SAAS,CAAC,gBAAgB,CAAC,UAAU,CAAC;AAC/C;AAFA,OAAA,CAAA,gBAAA,GAAA,gBAAA;AAIA,SAAgB,eAAe,CAAC,UAAkB,EAAE,UAAiB,EAAA;EAAjB,IAAA,UAAA,KAAA,KAAA,CAAA,EAAA;IAAA,UAAA,GAAA,IAAiB;EAAA;EACnE,OAAO,MAAM,CAAC,IAAI,CAAC,SAAS,CAAC,eAAe,CAAC,UAAU,EAAE,UAAU,CAAC,CAAC;AACvE;AAFA,OAAA,CAAA,eAAA,GAAA,eAAA;AAIA,SAAgB,eAAe,CAAC,SAAiB,EAAA;EAC/C,OAAO,SAAS,CAAC,eAAe,CAAC,SAAS,CAAC;AAC7C;AAFA,OAAA,CAAA,eAAA,GAAA,eAAA;AAIA,SAAgB,gBAAgB,CAAC,SAAiB,EAAE,UAAiB,EAAA;EAAjB,IAAA,UAAA,KAAA,KAAA,CAAA,EAAA;IAAA,UAAA,GAAA,IAAiB;EAAA;EACnE,OAAO,MAAM,CAAC,IAAI,CAAC,SAAS,CAAC,gBAAgB,CAAC,SAAS,EAAE,UAAU,CAAC,CAAC;AACvE;AAFA,OAAA,CAAA,gBAAA,GAAA,gBAAA;AAIA,SAAgB,kBAAkB,CAAC,SAAiB,EAAE,KAAa,EAAA;EACjE,OAAO,MAAM,CAAC,IAAI,CAChB,SAAS,CAAC,kBAAkB,CAAC,MAAM,CAAC,IAAI,CAAC,SAAS,CAAC,EAAE,KAAK,CAAC,CAC5D;AACH;AAJA,OAAA,CAAA,kBAAA,GAAA,kBAAA;AAMA,SAAgB,iBAAiB,CAC/B,SAAiB,EACjB,KAAa,EACb,UAAiB,EAAA;EAAjB,IAAA,UAAA,KAAA,KAAA,CAAA,EAAA;IAAA,UAAA,GAAA,IAAiB;EAAA;EAEjB,OAAO,MAAM,CAAC,IAAI,CAChB,SAAS,CAAC,iBAAiB,CAAC,MAAM,CAAC,IAAI,CAAC,SAAS,CAAC,EAAE,KAAK,EAAE,UAAU,CAAC,CACvE;AACH;AARA,OAAA,CAAA,iBAAA,GAAA,iBAAA;AAUA,SAAgB,IAAI,CAClB,OAAe,EACf,UAAkB,EAAA;EAElB,IAAM,GAAG,GAAG,SAAS,CAAC,SAAS,CAAC,OAAO,EAAE,UAAU,CAAC;EACpD,OAAO;IAAE,SAAS,EAAE,MAAM,CAAC,IAAI,CAAC,GAAG,CAAC,SAAS,CAAC;IAAE,QAAQ,EAAE,GAAG,CAAC;EAAK,CAAE;AACvE;AANA,OAAA,CAAA,IAAA,GAAA,IAAA;AAQA,SAAgB,MAAM,CACpB,OAAe,EACf,SAAiB,EACjB,SAAiB,EAAA;EAEjB,OAAO,SAAS,CAAC,WAAW,CAAC,SAAS,EAAE,OAAO,EAAE,SAAS,CAAC;AAC7D;AANA,OAAA,CAAA,MAAA,GAAA,MAAA","sourceRoot":"","sourcesContent":["\"use strict\";\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\n    result[\"default\"] = mod;\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar secp256k1 = __importStar(require(\"secp256k1\"));\nfunction privateKeyVerify(privateKey) {\n    return secp256k1.privateKeyVerify(privateKey);\n}\nexports.privateKeyVerify = privateKeyVerify;\nfunction publicKeyCreate(privateKey, compressed) {\n    if (compressed === void 0) { compressed = true; }\n    return Buffer.from(secp256k1.publicKeyCreate(privateKey, compressed));\n}\nexports.publicKeyCreate = publicKeyCreate;\nfunction publicKeyVerify(publicKey) {\n    return secp256k1.publicKeyVerify(publicKey);\n}\nexports.publicKeyVerify = publicKeyVerify;\nfunction publicKeyConvert(publicKey, compressed) {\n    if (compressed === void 0) { compressed = true; }\n    return Buffer.from(secp256k1.publicKeyConvert(publicKey, compressed));\n}\nexports.publicKeyConvert = publicKeyConvert;\nfunction privateKeyTweakAdd(publicKey, tweak) {\n    return Buffer.from(secp256k1.privateKeyTweakAdd(Buffer.from(publicKey), tweak));\n}\nexports.privateKeyTweakAdd = privateKeyTweakAdd;\nfunction publicKeyTweakAdd(publicKey, tweak, compressed) {\n    if (compressed === void 0) { compressed = true; }\n    return Buffer.from(secp256k1.publicKeyTweakAdd(Buffer.from(publicKey), tweak, compressed));\n}\nexports.publicKeyTweakAdd = publicKeyTweakAdd;\nfunction sign(message, privateKey) {\n    var ret = secp256k1.ecdsaSign(message, privateKey);\n    return { signature: Buffer.from(ret.signature), recovery: ret.recid };\n}\nexports.sign = sign;\nfunction verify(message, signature, publicKey) {\n    return secp256k1.ecdsaVerify(signature, message, publicKey);\n}\nexports.verify = verify;\n//# sourceMappingURL=hdkey-secp256k1v3.js.map"]},"metadata":{},"sourceType":"script"}