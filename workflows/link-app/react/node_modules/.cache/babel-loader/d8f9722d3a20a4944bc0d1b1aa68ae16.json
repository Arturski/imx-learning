{"ast":null,"code":"import { identity } from './function';\nimport * as S from './Semigroup';\n/**\n * `boolean` monoid under conjunction.\n *\n * The `empty` value is `true`.\n *\n * @example\n * import * as M from 'fp-ts/Monoid'\n *\n * assert.deepStrictEqual(M.monoidAll.concat(true, true), true)\n * assert.deepStrictEqual(M.monoidAll.concat(true, false), false)\n *\n * @category instances\n * @since 2.0.0\n */\nexport var monoidAll = {\n  concat: S.semigroupAll.concat,\n  empty: true\n};\n/**\n * `boolean` monoid under disjunction.\n *\n * The `empty` value is `false`.\n *\n * @example\n * import * as M from 'fp-ts/Monoid'\n *\n * assert.deepStrictEqual(M.monoidAny.concat(true, true), true)\n * assert.deepStrictEqual(M.monoidAny.concat(true, false), true)\n * assert.deepStrictEqual(M.monoidAny.concat(false, false), false)\n *\n * @category instances\n * @since 2.0.0\n */\nexport var monoidAny = {\n  concat: S.semigroupAny.concat,\n  empty: false\n};\n/**\n * `number` monoid under addition.\n *\n * The `empty` value is `0`.\n *\n * @example\n * import * as M from 'fp-ts/Monoid'\n *\n * assert.deepStrictEqual(M.monoidSum.concat(2, 3), 5)\n *\n * @category instances\n * @since 2.0.0\n */\nexport var monoidSum = {\n  concat: S.semigroupSum.concat,\n  empty: 0\n};\n/**\n * `number` monoid under multiplication.\n *\n * The `empty` value is `1`.\n *\n * @example\n * import * as M from 'fp-ts/Monoid'\n *\n * assert.deepStrictEqual(M.monoidProduct.concat(2, 3), 6)\n *\n * @category instances\n * @since 2.0.0\n */\nexport var monoidProduct = {\n  concat: S.semigroupProduct.concat,\n  empty: 1\n};\n/**\n * `string` monoid under concatenation.\n *\n * The `empty` value is `''`.\n *\n * @example\n * import * as M from 'fp-ts/Monoid'\n *\n * assert.deepStrictEqual(M.monoidString.concat('a', 'b'), 'ab')\n *\n * @category instances\n * @since 2.0.0\n */\nexport var monoidString = {\n  concat: S.semigroupString.concat,\n  empty: ''\n};\n/**\n * @category instances\n * @since 2.0.0\n */\nexport var monoidVoid = {\n  concat: S.semigroupVoid.concat,\n  empty: undefined\n};\n/**\n * Given a sequence of `as`, concat them and return the total.\n *\n * If `as` is empty, return the monoid `empty` value.\n *\n * @example\n * import * as M from 'fp-ts/Monoid'\n *\n * assert.deepStrictEqual(M.fold(M.monoidSum)([1, 2, 3]), 6)\n * assert.deepStrictEqual(M.fold(M.monoidSum)([]), 0)\n *\n * @since 2.0.0\n */\nexport function fold(M) {\n  return S.fold(M)(M.empty);\n}\n/**\n * Given a tuple of monoids returns a monoid for the tuple\n *\n * @example\n * import { getTupleMonoid, monoidString, monoidSum, monoidAll } from 'fp-ts/Monoid'\n *\n * const M1 = getTupleMonoid(monoidString, monoidSum)\n * assert.deepStrictEqual(M1.concat(['a', 1], ['b', 2]), ['ab', 3])\n *\n * const M2 = getTupleMonoid(monoidString, monoidSum, monoidAll)\n * assert.deepStrictEqual(M2.concat(['a', 1, true], ['b', 2, false]), ['ab', 3, false])\n *\n * @category instances\n * @since 2.0.0\n */\nexport function getTupleMonoid() {\n  var monoids = [];\n  for (var _i = 0; _i < arguments.length; _i++) {\n    monoids[_i] = arguments[_i];\n  }\n  return {\n    concat: S.getTupleSemigroup.apply(S, monoids).concat,\n    empty: monoids.map(function (m) {\n      return m.empty;\n    })\n  };\n}\n/**\n * The dual of a `Monoid`, obtained by swapping the arguments of `concat`.\n *\n * @example\n * import { getDualMonoid, monoidString } from 'fp-ts/Monoid'\n *\n * assert.deepStrictEqual(getDualMonoid(monoidString).concat('a', 'b'), 'ba')\n *\n * @category combinators\n * @since 2.0.0\n */\nexport function getDualMonoid(M) {\n  return {\n    concat: S.getDualSemigroup(M).concat,\n    empty: M.empty\n  };\n}\n/**\n * Unary functions form a monoid as long as you can provide a monoid for the codomain.\n *\n * @example\n * import { Predicate } from 'fp-ts/function'\n * import * as M from 'fp-ts/Monoid'\n *\n * const f: Predicate<number> = (n) => n <= 2\n * const g: Predicate<number> = (n) => n >= 0\n *\n * const M1 = M.getFunctionMonoid(M.monoidAll)<number>()\n *\n * assert.deepStrictEqual(M1.concat(f, g)(1), true)\n * assert.deepStrictEqual(M1.concat(f, g)(3), false)\n *\n * const M2 = M.getFunctionMonoid(M.monoidAny)<number>()\n *\n * assert.deepStrictEqual(M2.concat(f, g)(1), true)\n * assert.deepStrictEqual(M2.concat(f, g)(3), true)\n *\n * @category instances\n * @since 2.0.0\n */\nexport function getFunctionMonoid(M) {\n  return function () {\n    return {\n      concat: S.getFunctionSemigroup(M)().concat,\n      empty: function () {\n        return M.empty;\n      }\n    };\n  };\n}\n// TODO: swap execution order in v3\n/**\n * Endomorphism form a monoid where the `empty` value is the identity function.\n *\n * @category instances\n * @since 2.0.0\n */\nexport function getEndomorphismMonoid() {\n  return {\n    concat: function (x, y) {\n      return function (a) {\n        return x(y(a));\n      };\n    },\n    empty: identity\n  };\n}\n/**\n * Given a struct of monoids returns a monoid for the struct.\n *\n * @example\n * import * as M from 'fp-ts/Monoid'\n *\n * interface Point {\n *   readonly x: number\n *   readonly y: number\n * }\n *\n * const monoidPoint = M.getStructMonoid<Point>({\n *   x: M.monoidSum,\n *   y: M.monoidSum\n * })\n *\n * assert.deepStrictEqual(monoidPoint.concat({ x: 1, y: 2 }, { x: 3, y: 4 }), { x: 4, y: 6 })\n *\n * @category instances\n * @since 2.0.0\n */\nexport function getStructMonoid(monoids) {\n  var empty = {};\n  for (var _i = 0, _a = Object.keys(monoids); _i < _a.length; _i++) {\n    var key = _a[_i];\n    empty[key] = monoids[key].empty;\n  }\n  return {\n    concat: S.getStructSemigroup(monoids).concat,\n    empty: empty\n  };\n}\n/**\n * Get a monoid where `concat` will return the minimum, based on the provided bounded order.\n *\n * The `empty` value is the `top` value.\n *\n * @example\n * import * as B from 'fp-ts/Bounded'\n * import * as M from 'fp-ts/Monoid'\n *\n * const M1 = M.getMeetMonoid(B.boundedNumber)\n *\n * assert.deepStrictEqual(M1.concat(1, 2), 1)\n *\n * @category instances\n * @since 2.0.0\n */\nexport function getMeetMonoid(B) {\n  return {\n    concat: S.getMeetSemigroup(B).concat,\n    empty: B.top\n  };\n}\n/**\n * Get a monoid where `concat` will return the maximum, based on the provided bounded order.\n *\n * The `empty` value is the `bottom` value.\n *\n * @example\n * import * as B from 'fp-ts/Bounded'\n * import * as M from 'fp-ts/Monoid'\n *\n * const M1 = M.getJoinMonoid(B.boundedNumber)\n *\n * assert.deepStrictEqual(M1.concat(1, 2), 2)\n *\n * @category instances\n * @since 2.0.0\n */\nexport function getJoinMonoid(B) {\n  return {\n    concat: S.getJoinSemigroup(B).concat,\n    empty: B.bottom\n  };\n}","map":{"version":3,"names":["identity","S","monoidAll","concat","semigroupAll","empty","monoidAny","semigroupAny","monoidSum","semigroupSum","monoidProduct","semigroupProduct","monoidString","semigroupString","monoidVoid","semigroupVoid","undefined","fold","M","getTupleMonoid","monoids","_i","arguments","length","getTupleSemigroup","apply","map","m","getDualMonoid","getDualSemigroup","getFunctionMonoid","getFunctionSemigroup","getEndomorphismMonoid","x","y","a","getStructMonoid","_a","Object","keys","key","getStructSemigroup","getMeetMonoid","B","getMeetSemigroup","top","getJoinMonoid","getJoinSemigroup","bottom"],"sources":["/Users/arthurfrancis/Documents/repo/imx-learning/workflows/link-app/react/node_modules/fp-ts/es6/Monoid.js"],"sourcesContent":["import { identity } from './function';\nimport * as S from './Semigroup';\n/**\n * `boolean` monoid under conjunction.\n *\n * The `empty` value is `true`.\n *\n * @example\n * import * as M from 'fp-ts/Monoid'\n *\n * assert.deepStrictEqual(M.monoidAll.concat(true, true), true)\n * assert.deepStrictEqual(M.monoidAll.concat(true, false), false)\n *\n * @category instances\n * @since 2.0.0\n */\nexport var monoidAll = {\n    concat: S.semigroupAll.concat,\n    empty: true\n};\n/**\n * `boolean` monoid under disjunction.\n *\n * The `empty` value is `false`.\n *\n * @example\n * import * as M from 'fp-ts/Monoid'\n *\n * assert.deepStrictEqual(M.monoidAny.concat(true, true), true)\n * assert.deepStrictEqual(M.monoidAny.concat(true, false), true)\n * assert.deepStrictEqual(M.monoidAny.concat(false, false), false)\n *\n * @category instances\n * @since 2.0.0\n */\nexport var monoidAny = {\n    concat: S.semigroupAny.concat,\n    empty: false\n};\n/**\n * `number` monoid under addition.\n *\n * The `empty` value is `0`.\n *\n * @example\n * import * as M from 'fp-ts/Monoid'\n *\n * assert.deepStrictEqual(M.monoidSum.concat(2, 3), 5)\n *\n * @category instances\n * @since 2.0.0\n */\nexport var monoidSum = {\n    concat: S.semigroupSum.concat,\n    empty: 0\n};\n/**\n * `number` monoid under multiplication.\n *\n * The `empty` value is `1`.\n *\n * @example\n * import * as M from 'fp-ts/Monoid'\n *\n * assert.deepStrictEqual(M.monoidProduct.concat(2, 3), 6)\n *\n * @category instances\n * @since 2.0.0\n */\nexport var monoidProduct = {\n    concat: S.semigroupProduct.concat,\n    empty: 1\n};\n/**\n * `string` monoid under concatenation.\n *\n * The `empty` value is `''`.\n *\n * @example\n * import * as M from 'fp-ts/Monoid'\n *\n * assert.deepStrictEqual(M.monoidString.concat('a', 'b'), 'ab')\n *\n * @category instances\n * @since 2.0.0\n */\nexport var monoidString = {\n    concat: S.semigroupString.concat,\n    empty: ''\n};\n/**\n * @category instances\n * @since 2.0.0\n */\nexport var monoidVoid = {\n    concat: S.semigroupVoid.concat,\n    empty: undefined\n};\n/**\n * Given a sequence of `as`, concat them and return the total.\n *\n * If `as` is empty, return the monoid `empty` value.\n *\n * @example\n * import * as M from 'fp-ts/Monoid'\n *\n * assert.deepStrictEqual(M.fold(M.monoidSum)([1, 2, 3]), 6)\n * assert.deepStrictEqual(M.fold(M.monoidSum)([]), 0)\n *\n * @since 2.0.0\n */\nexport function fold(M) {\n    return S.fold(M)(M.empty);\n}\n/**\n * Given a tuple of monoids returns a monoid for the tuple\n *\n * @example\n * import { getTupleMonoid, monoidString, monoidSum, monoidAll } from 'fp-ts/Monoid'\n *\n * const M1 = getTupleMonoid(monoidString, monoidSum)\n * assert.deepStrictEqual(M1.concat(['a', 1], ['b', 2]), ['ab', 3])\n *\n * const M2 = getTupleMonoid(monoidString, monoidSum, monoidAll)\n * assert.deepStrictEqual(M2.concat(['a', 1, true], ['b', 2, false]), ['ab', 3, false])\n *\n * @category instances\n * @since 2.0.0\n */\nexport function getTupleMonoid() {\n    var monoids = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        monoids[_i] = arguments[_i];\n    }\n    return {\n        concat: S.getTupleSemigroup.apply(S, monoids).concat,\n        empty: monoids.map(function (m) { return m.empty; })\n    };\n}\n/**\n * The dual of a `Monoid`, obtained by swapping the arguments of `concat`.\n *\n * @example\n * import { getDualMonoid, monoidString } from 'fp-ts/Monoid'\n *\n * assert.deepStrictEqual(getDualMonoid(monoidString).concat('a', 'b'), 'ba')\n *\n * @category combinators\n * @since 2.0.0\n */\nexport function getDualMonoid(M) {\n    return {\n        concat: S.getDualSemigroup(M).concat,\n        empty: M.empty\n    };\n}\n/**\n * Unary functions form a monoid as long as you can provide a monoid for the codomain.\n *\n * @example\n * import { Predicate } from 'fp-ts/function'\n * import * as M from 'fp-ts/Monoid'\n *\n * const f: Predicate<number> = (n) => n <= 2\n * const g: Predicate<number> = (n) => n >= 0\n *\n * const M1 = M.getFunctionMonoid(M.monoidAll)<number>()\n *\n * assert.deepStrictEqual(M1.concat(f, g)(1), true)\n * assert.deepStrictEqual(M1.concat(f, g)(3), false)\n *\n * const M2 = M.getFunctionMonoid(M.monoidAny)<number>()\n *\n * assert.deepStrictEqual(M2.concat(f, g)(1), true)\n * assert.deepStrictEqual(M2.concat(f, g)(3), true)\n *\n * @category instances\n * @since 2.0.0\n */\nexport function getFunctionMonoid(M) {\n    return function () { return ({\n        concat: S.getFunctionSemigroup(M)().concat,\n        empty: function () { return M.empty; }\n    }); };\n}\n// TODO: swap execution order in v3\n/**\n * Endomorphism form a monoid where the `empty` value is the identity function.\n *\n * @category instances\n * @since 2.0.0\n */\nexport function getEndomorphismMonoid() {\n    return {\n        concat: function (x, y) { return function (a) { return x(y(a)); }; },\n        empty: identity\n    };\n}\n/**\n * Given a struct of monoids returns a monoid for the struct.\n *\n * @example\n * import * as M from 'fp-ts/Monoid'\n *\n * interface Point {\n *   readonly x: number\n *   readonly y: number\n * }\n *\n * const monoidPoint = M.getStructMonoid<Point>({\n *   x: M.monoidSum,\n *   y: M.monoidSum\n * })\n *\n * assert.deepStrictEqual(monoidPoint.concat({ x: 1, y: 2 }, { x: 3, y: 4 }), { x: 4, y: 6 })\n *\n * @category instances\n * @since 2.0.0\n */\nexport function getStructMonoid(monoids) {\n    var empty = {};\n    for (var _i = 0, _a = Object.keys(monoids); _i < _a.length; _i++) {\n        var key = _a[_i];\n        empty[key] = monoids[key].empty;\n    }\n    return {\n        concat: S.getStructSemigroup(monoids).concat,\n        empty: empty\n    };\n}\n/**\n * Get a monoid where `concat` will return the minimum, based on the provided bounded order.\n *\n * The `empty` value is the `top` value.\n *\n * @example\n * import * as B from 'fp-ts/Bounded'\n * import * as M from 'fp-ts/Monoid'\n *\n * const M1 = M.getMeetMonoid(B.boundedNumber)\n *\n * assert.deepStrictEqual(M1.concat(1, 2), 1)\n *\n * @category instances\n * @since 2.0.0\n */\nexport function getMeetMonoid(B) {\n    return {\n        concat: S.getMeetSemigroup(B).concat,\n        empty: B.top\n    };\n}\n/**\n * Get a monoid where `concat` will return the maximum, based on the provided bounded order.\n *\n * The `empty` value is the `bottom` value.\n *\n * @example\n * import * as B from 'fp-ts/Bounded'\n * import * as M from 'fp-ts/Monoid'\n *\n * const M1 = M.getJoinMonoid(B.boundedNumber)\n *\n * assert.deepStrictEqual(M1.concat(1, 2), 2)\n *\n * @category instances\n * @since 2.0.0\n */\nexport function getJoinMonoid(B) {\n    return {\n        concat: S.getJoinSemigroup(B).concat,\n        empty: B.bottom\n    };\n}\n"],"mappings":"AAAA,SAASA,QAAQ,QAAQ,YAAY;AACrC,OAAO,KAAKC,CAAC,MAAM,aAAa;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,IAAIC,SAAS,GAAG;EACnBC,MAAM,EAAEF,CAAC,CAACG,YAAY,CAACD,MAAM;EAC7BE,KAAK,EAAE;AACX,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,IAAIC,SAAS,GAAG;EACnBH,MAAM,EAAEF,CAAC,CAACM,YAAY,CAACJ,MAAM;EAC7BE,KAAK,EAAE;AACX,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,IAAIG,SAAS,GAAG;EACnBL,MAAM,EAAEF,CAAC,CAACQ,YAAY,CAACN,MAAM;EAC7BE,KAAK,EAAE;AACX,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,IAAIK,aAAa,GAAG;EACvBP,MAAM,EAAEF,CAAC,CAACU,gBAAgB,CAACR,MAAM;EACjCE,KAAK,EAAE;AACX,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,IAAIO,YAAY,GAAG;EACtBT,MAAM,EAAEF,CAAC,CAACY,eAAe,CAACV,MAAM;EAChCE,KAAK,EAAE;AACX,CAAC;AACD;AACA;AACA;AACA;AACA,OAAO,IAAIS,UAAU,GAAG;EACpBX,MAAM,EAAEF,CAAC,CAACc,aAAa,CAACZ,MAAM;EAC9BE,KAAK,EAAEW;AACX,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASC,IAAI,CAACC,CAAC,EAAE;EACpB,OAAOjB,CAAC,CAACgB,IAAI,CAACC,CAAC,CAAC,CAACA,CAAC,CAACb,KAAK,CAAC;AAC7B;AACA;AACA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"},"metadata":{},"sourceType":"module"}