{"ast":null,"code":"import { identity, pipe, bind_, bindTo_, flow } from './function';\n// -------------------------------------------------------------------------------------\n// guards\n// -------------------------------------------------------------------------------------\n/**\n * Returns `true` if the option is an instance of `Some`, `false` otherwise.\n *\n * @example\n * import { some, none, isSome } from 'fp-ts/Option'\n *\n * assert.strictEqual(isSome(some(1)), true)\n * assert.strictEqual(isSome(none), false)\n *\n * @category guards\n * @since 2.0.0\n */\nexport var isSome = function (fa) {\n  return fa._tag === 'Some';\n};\n/**\n * Returns `true` if the option is `None`, `false` otherwise.\n *\n * @example\n * import { some, none, isNone } from 'fp-ts/Option'\n *\n * assert.strictEqual(isNone(some(1)), false)\n * assert.strictEqual(isNone(none), true)\n *\n * @category guards\n * @since 2.0.0\n */\nexport var isNone = function (fa) {\n  return fa._tag === 'None';\n};\n// -------------------------------------------------------------------------------------\n// constructors\n// -------------------------------------------------------------------------------------\n/**\n * `None` doesn't have a constructor, instead you can use it directly as a value. Represents a missing value.\n *\n * @category constructors\n * @since 2.0.0\n */\nexport var none = {\n  _tag: 'None'\n};\n/**\n * Constructs a `Some`. Represents an optional value that exists.\n *\n * @category constructors\n * @since 2.0.0\n */\nexport var some = function (a) {\n  return {\n    _tag: 'Some',\n    value: a\n  };\n};\n/**\n * Constructs a new `Option` from a nullable type. If the value is `null` or `undefined`, returns `None`, otherwise\n * returns the value wrapped in a `Some`.\n *\n * @example\n * import { none, some, fromNullable } from 'fp-ts/Option'\n *\n * assert.deepStrictEqual(fromNullable(undefined), none)\n * assert.deepStrictEqual(fromNullable(null), none)\n * assert.deepStrictEqual(fromNullable(1), some(1))\n *\n * @category constructors\n * @since 2.0.0\n */\nexport function fromNullable(a) {\n  return a == null ? none : some(a);\n}\nexport function fromPredicate(predicate) {\n  return function (a) {\n    return predicate(a) ? some(a) : none;\n  };\n}\n/**\n * Transforms an exception into an `Option`. If `f` throws, returns `None`, otherwise returns the output wrapped in a\n * `Some`.\n *\n * @example\n * import { none, some, tryCatch } from 'fp-ts/Option'\n *\n * assert.deepStrictEqual(\n *   tryCatch(() => {\n *     throw new Error()\n *   }),\n *   none\n * )\n * assert.deepStrictEqual(tryCatch(() => 1), some(1))\n *\n * @category constructors\n * @since 2.0.0\n */\nexport function tryCatch(f) {\n  try {\n    return some(f());\n  } catch (e) {\n    return none;\n  }\n}\n/**\n * Returns the `Left` value of an `Either` if possible.\n *\n * @example\n * import { getLeft, none, some } from 'fp-ts/Option'\n * import { right, left } from 'fp-ts/Either'\n *\n * assert.deepStrictEqual(getLeft(right(1)), none)\n * assert.deepStrictEqual(getLeft(left('a')), some('a'))\n *\n * @category constructors\n * @since 2.0.0\n */\nexport function getLeft(ma) {\n  return ma._tag === 'Right' ? none : some(ma.left);\n}\n/**\n * Returns the `Right` value of an `Either` if possible.\n *\n * @example\n * import { getRight, none, some } from 'fp-ts/Option'\n * import { right, left } from 'fp-ts/Either'\n *\n * assert.deepStrictEqual(getRight(right(1)), some(1))\n * assert.deepStrictEqual(getRight(left('a')), none)\n *\n * @category constructors\n * @since 2.0.0\n */\nexport function getRight(ma) {\n  return ma._tag === 'Left' ? none : some(ma.right);\n}\n/**\n * Transforms an `Either` to an `Option` discarding the error.\n *\n * Alias of [getRight](#getRight)\n *\n * Derivable from `MonadThrow`.\n *\n * @category constructors\n * @since 2.0.0\n */\nexport var fromEither = getRight;\n// -------------------------------------------------------------------------------------\n// destructors\n// -------------------------------------------------------------------------------------\n/**\n * Takes a (lazy) default value, a function, and an `Option` value, if the `Option` value is `None` the default value is\n * returned, otherwise the function is applied to the value inside the `Some` and the result is returned.\n *\n * @example\n * import { some, none, fold } from 'fp-ts/Option'\n * import { pipe } from 'fp-ts/function'\n *\n * assert.strictEqual(\n *   pipe(\n *     some(1),\n *     fold(() => 'a none', a => `a some containing ${a}`)\n *   ),\n *   'a some containing 1'\n * )\n *\n * assert.strictEqual(\n *   pipe(\n *     none,\n *     fold(() => 'a none', a => `a some containing ${a}`)\n *   ),\n *   'a none'\n * )\n *\n * @category destructors\n * @since 2.0.0\n */\nexport function fold(onNone, onSome) {\n  return function (ma) {\n    return isNone(ma) ? onNone() : onSome(ma.value);\n  };\n}\n/**\n * Extracts the value out of the structure, if it exists. Otherwise returns `null`.\n *\n * @example\n * import { some, none, toNullable } from 'fp-ts/Option'\n * import { pipe } from 'fp-ts/function'\n *\n * assert.strictEqual(\n *   pipe(\n *     some(1),\n *     toNullable\n *   ),\n *   1\n * )\n * assert.strictEqual(\n *   pipe(\n *     none,\n *     toNullable\n *   ),\n *   null\n * )\n *\n * @category destructors\n * @since 2.0.0\n */\nexport function toNullable(ma) {\n  return isNone(ma) ? null : ma.value;\n}\n/**\n * Extracts the value out of the structure, if it exists. Otherwise returns `undefined`.\n *\n * @example\n * import { some, none, toUndefined } from 'fp-ts/Option'\n * import { pipe } from 'fp-ts/function'\n *\n * assert.strictEqual(\n *   pipe(\n *     some(1),\n *     toUndefined\n *   ),\n *   1\n * )\n * assert.strictEqual(\n *   pipe(\n *     none,\n *     toUndefined\n *   ),\n *   undefined\n * )\n *\n * @category destructors\n * @since 2.0.0\n */\nexport function toUndefined(ma) {\n  return isNone(ma) ? undefined : ma.value;\n}\n/**\n * Less strict version of [`getOrElse`](#getOrElse).\n *\n * @category destructors\n * @since 2.6.0\n */\nexport var getOrElseW = function (onNone) {\n  return function (ma) {\n    return isNone(ma) ? onNone() : ma.value;\n  };\n};\n/**\n * Extracts the value out of the structure, if it exists. Otherwise returns the given default value\n *\n * @example\n * import { some, none, getOrElse } from 'fp-ts/Option'\n * import { pipe } from 'fp-ts/function'\n *\n * assert.strictEqual(\n *   pipe(\n *     some(1),\n *     getOrElse(() => 0)\n *   ),\n *   1\n * )\n * assert.strictEqual(\n *   pipe(\n *     none,\n *     getOrElse(() => 0)\n *   ),\n *   0\n * )\n *\n * @category destructors\n * @since 2.0.0\n */\nexport var getOrElse = getOrElseW;\n// -------------------------------------------------------------------------------------\n// combinators\n// -------------------------------------------------------------------------------------\n/**\n * Returns a *smart constructor* from a function that returns a nullable value.\n *\n * @example\n * import { fromNullableK, none, some } from 'fp-ts/Option'\n *\n * const f = (s: string): number | undefined => {\n *   const n = parseFloat(s)\n *   return isNaN(n) ? undefined : n\n * }\n *\n * const g = fromNullableK(f)\n *\n * assert.deepStrictEqual(g('1'), some(1))\n * assert.deepStrictEqual(g('a'), none)\n *\n * @category combinators\n * @since 2.9.0\n */\nexport function fromNullableK(f) {\n  return function () {\n    var a = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n      a[_i] = arguments[_i];\n    }\n    return fromNullable(f.apply(void 0, a));\n  };\n}\n/**\n * @category combinators\n * @since 2.0.0\n * @deprecated\n */\nexport var mapNullable = chainNullableK;\n/**\n * This is `chain` + `fromNullable`, useful when working with optional values.\n *\n * @example\n * import { some, none, fromNullable, chainNullableK } from 'fp-ts/Option'\n * import { pipe } from 'fp-ts/function'\n *\n * interface Employee {\n *   company?: {\n *     address?: {\n *       street?: {\n *         name?: string\n *       }\n *     }\n *   }\n * }\n *\n * const employee1: Employee = { company: { address: { street: { name: 'high street' } } } }\n *\n * assert.deepStrictEqual(\n *   pipe(\n *     fromNullable(employee1.company),\n *     chainNullableK(company => company.address),\n *     chainNullableK(address => address.street),\n *     chainNullableK(street => street.name)\n *   ),\n *   some('high street')\n * )\n *\n * const employee2: Employee = { company: { address: { street: {} } } }\n *\n * assert.deepStrictEqual(\n *   pipe(\n *     fromNullable(employee2.company),\n *     chainNullableK(company => company.address),\n *     chainNullableK(address => address.street),\n *     chainNullableK(street => street.name)\n *   ),\n *   none\n * )\n *\n * @category combinators\n * @since 2.9.0\n */\nexport function chainNullableK(f) {\n  return function (ma) {\n    return isNone(ma) ? none : fromNullable(f(ma.value));\n  };\n}\n// -------------------------------------------------------------------------------------\n// non-pipeables\n// -------------------------------------------------------------------------------------\nvar map_ = function (fa, f) {\n  return pipe(fa, map(f));\n};\nvar ap_ = function (fab, fa) {\n  return pipe(fab, ap(fa));\n};\nvar chain_ = function (ma, f) {\n  return pipe(ma, chain(f));\n};\nvar reduce_ = function (fa, b, f) {\n  return pipe(fa, reduce(b, f));\n};\nvar foldMap_ = function (M) {\n  var foldMapM = foldMap(M);\n  return function (fa, f) {\n    return pipe(fa, foldMapM(f));\n  };\n};\nvar reduceRight_ = function (fa, b, f) {\n  return pipe(fa, reduceRight(b, f));\n};\nvar traverse_ = function (F) {\n  var traverseF = traverse(F);\n  return function (ta, f) {\n    return pipe(ta, traverseF(f));\n  };\n};\n/* istanbul ignore next */\nvar alt_ = function (fa, that) {\n  return pipe(fa, alt(that));\n};\nvar filter_ = function (fa, predicate) {\n  return pipe(fa, filter(predicate));\n};\n/* istanbul ignore next */\nvar filterMap_ = function (fa, f) {\n  return pipe(fa, filterMap(f));\n};\n/* istanbul ignore next */\nvar extend_ = function (wa, f) {\n  return pipe(wa, extend(f));\n};\n/* istanbul ignore next */\nvar partition_ = function (fa, predicate) {\n  return pipe(fa, partition(predicate));\n};\n/* istanbul ignore next */\nvar partitionMap_ = function (fa, f) {\n  return pipe(fa, partitionMap(f));\n};\n/* istanbul ignore next */\nvar wither_ = function (F) {\n  var witherF = wither(F);\n  return function (fa, f) {\n    return pipe(fa, witherF(f));\n  };\n};\n/* istanbul ignore next */\nvar wilt_ = function (F) {\n  var wiltF = wilt(F);\n  return function (fa, f) {\n    return pipe(fa, wiltF(f));\n  };\n};\n// -------------------------------------------------------------------------------------\n// pipeables\n// -------------------------------------------------------------------------------------\n/**\n * `map` can be used to turn functions `(a: A) => B` into functions `(fa: F<A>) => F<B>` whose argument and return types\n * use the type constructor `F` to represent some computational context.\n *\n * @category Functor\n * @since 2.0.0\n */\nexport var map = function (f) {\n  return function (fa) {\n    return isNone(fa) ? none : some(f(fa.value));\n  };\n};\n/**\n * Apply a function to an argument under a type constructor.\n *\n * @category Apply\n * @since 2.0.0\n */\nexport var ap = function (fa) {\n  return function (fab) {\n    return isNone(fab) ? none : isNone(fa) ? none : some(fab.value(fa.value));\n  };\n};\n/**\n * Combine two effectful actions, keeping only the result of the first.\n *\n * Derivable from `Apply`.\n *\n * @category combinators\n * @since 2.0.0\n */\nexport var apFirst = function (fb) {\n  return flow(map(function (a) {\n    return function () {\n      return a;\n    };\n  }), ap(fb));\n};\n/**\n * Combine two effectful actions, keeping only the result of the second.\n *\n * Derivable from `Apply`.\n *\n * @category combinators\n * @since 2.0.0\n */\nexport var apSecond = function (fb) {\n  return flow(map(function () {\n    return function (b) {\n      return b;\n    };\n  }), ap(fb));\n};\n/**\n * Wrap a value into the type constructor.\n *\n * @category Applicative\n * @since 2.7.0\n */\nexport var of = some;\n/**\n * Composes computations in sequence, using the return value of one computation to determine the next computation.\n *\n * @category Monad\n * @since 2.0.0\n */\nexport var chain = function (f) {\n  return function (ma) {\n    return isNone(ma) ? none : f(ma.value);\n  };\n};\n/**\n * Composes computations in sequence, using the return value of one computation to determine the next computation and\n * keeping only the result of the first.\n *\n * Derivable from `Monad`.\n *\n * @category combinators\n * @since 2.0.0\n */\nexport var chainFirst = function (f) {\n  return chain(function (a) {\n    return pipe(f(a), map(function () {\n      return a;\n    }));\n  });\n};\n/**\n * Derivable from `Monad`.\n *\n * @category combinators\n * @since 2.0.0\n */\nexport var flatten = /*#__PURE__*/\nchain(identity);\n/**\n * Less strict version of [`alt`](#alt).\n *\n * @category Alt\n * @since 2.9.0\n */\nexport var altW = function (that) {\n  return function (fa) {\n    return isNone(fa) ? that() : fa;\n  };\n};\n/**\n * Identifies an associative operation on a type constructor. It is similar to `Semigroup`, except that it applies to\n * types of kind `* -> *`.\n *\n * In case of `Option` returns the left-most non-`None` value.\n *\n * @example\n * import * as O from 'fp-ts/Option'\n * import { pipe } from 'fp-ts/function'\n *\n * assert.deepStrictEqual(\n *   pipe(\n *     O.some('a'),\n *     O.alt(() => O.some('b'))\n *   ),\n *   O.some('a')\n * )\n * assert.deepStrictEqual(\n *   pipe(\n *     O.none,\n *     O.alt(() => O.some('b'))\n *   ),\n *   O.some('b')\n * )\n *\n * @category Alt\n * @since 2.0.0\n */\nexport var alt = altW;\n/**\n * @category Alternative\n * @since 2.7.0\n */\nexport var zero = function () {\n  return none;\n};\n/**\n * @category MonadThrow\n * @since 2.7.0\n */\nexport var throwError = function () {\n  return none;\n};\n/**\n * @category Extend\n * @since 2.0.0\n */\nexport var extend = function (f) {\n  return function (wa) {\n    return isNone(wa) ? none : some(f(wa));\n  };\n};\n/**\n * Derivable from `Extend`.\n *\n * @category combinators\n * @since 2.0.0\n */\nexport var duplicate = /*#__PURE__*/\nextend(identity);\n/**\n * @category Foldable\n * @since 2.0.0\n */\nexport var reduce = function (b, f) {\n  return function (fa) {\n    return isNone(fa) ? b : f(b, fa.value);\n  };\n};\n/**\n * @category Foldable\n * @since 2.0.0\n */\nexport var foldMap = function (M) {\n  return function (f) {\n    return function (fa) {\n      return isNone(fa) ? M.empty : f(fa.value);\n    };\n  };\n};\n/**\n * @category Foldable\n * @since 2.0.0\n */\nexport var reduceRight = function (b, f) {\n  return function (fa) {\n    return isNone(fa) ? b : f(fa.value, b);\n  };\n};\n/**\n * @category Compactable\n * @since 2.0.0\n */\nexport var compact = flatten;\nvar defaultSeparate = {\n  left: none,\n  right: none\n};\n/**\n * @category Compactable\n * @since 2.0.0\n */\nexport var separate = function (ma) {\n  var o = pipe(ma, map(function (e) {\n    return {\n      left: getLeft(e),\n      right: getRight(e)\n    };\n  }));\n  return isNone(o) ? defaultSeparate : o.value;\n};\n/**\n * @category Filterable\n * @since 2.0.0\n */\nexport var filter = function (predicate) {\n  return function (fa) {\n    return isNone(fa) ? none : predicate(fa.value) ? fa : none;\n  };\n};\n/**\n * @category Filterable\n * @since 2.0.0\n */\nexport var filterMap = function (f) {\n  return function (fa) {\n    return isNone(fa) ? none : f(fa.value);\n  };\n};\n/**\n * @category Filterable\n * @since 2.0.0\n */\nexport var partition = function (predicate) {\n  return function (fa) {\n    return {\n      left: filter_(fa, function (a) {\n        return !predicate(a);\n      }),\n      right: filter_(fa, predicate)\n    };\n  };\n};\n/**\n * @category Filterable\n * @since 2.0.0\n */\nexport var partitionMap = function (f) {\n  return flow(map(f), separate);\n};\n/**\n * @category Traversable\n * @since 2.6.3\n */\nexport var traverse = function (F) {\n  return function (f) {\n    return function (ta) {\n      return isNone(ta) ? F.of(none) : F.map(f(ta.value), some);\n    };\n  };\n};\n/**\n * @category Traversable\n * @since 2.6.3\n */\nexport var sequence = function (F) {\n  return function (ta) {\n    return isNone(ta) ? F.of(none) : F.map(ta.value, some);\n  };\n};\n/**\n * @category Witherable\n * @since 2.6.5\n */\nexport var wither = function (F) {\n  return function (f) {\n    return function (fa) {\n      return isNone(fa) ? F.of(none) : f(fa.value);\n    };\n  };\n};\n/**\n * @category Witherable\n * @since 2.6.5\n */\nexport var wilt = function (F) {\n  return function (f) {\n    return function (fa) {\n      return isNone(fa) ? F.of({\n        left: none,\n        right: none\n      }) : F.map(f(fa.value), function (e) {\n        return {\n          left: getLeft(e),\n          right: getRight(e)\n        };\n      });\n    };\n  };\n};\n// -------------------------------------------------------------------------------------\n// instances\n// -------------------------------------------------------------------------------------\n/**\n * @category instances\n * @since 2.0.0\n */\nexport var URI = 'Option';\n/**\n * @category instances\n * @since 2.0.0\n */\nexport function getShow(S) {\n  return {\n    show: function (ma) {\n      return isNone(ma) ? 'none' : \"some(\" + S.show(ma.value) + \")\";\n    }\n  };\n}\n/**\n * @example\n * import { none, some, getEq } from 'fp-ts/Option'\n * import { eqNumber } from 'fp-ts/Eq'\n *\n * const E = getEq(eqNumber)\n * assert.strictEqual(E.equals(none, none), true)\n * assert.strictEqual(E.equals(none, some(1)), false)\n * assert.strictEqual(E.equals(some(1), none), false)\n * assert.strictEqual(E.equals(some(1), some(2)), false)\n * assert.strictEqual(E.equals(some(1), some(1)), true)\n *\n * @category instances\n * @since 2.0.0\n */\nexport function getEq(E) {\n  return {\n    equals: function (x, y) {\n      return x === y || (isNone(x) ? isNone(y) : isNone(y) ? false : E.equals(x.value, y.value));\n    }\n  };\n}\n/**\n * The `Ord` instance allows `Option` values to be compared with\n * `compare`, whenever there is an `Ord` instance for\n * the type the `Option` contains.\n *\n * `None` is considered to be less than any `Some` value.\n *\n *\n * @example\n * import { none, some, getOrd } from 'fp-ts/Option'\n * import { ordNumber } from 'fp-ts/Ord'\n *\n * const O = getOrd(ordNumber)\n * assert.strictEqual(O.compare(none, none), 0)\n * assert.strictEqual(O.compare(none, some(1)), -1)\n * assert.strictEqual(O.compare(some(1), none), 1)\n * assert.strictEqual(O.compare(some(1), some(2)), -1)\n * assert.strictEqual(O.compare(some(1), some(1)), 0)\n *\n * @category instances\n * @since 2.0.0\n */\nexport function getOrd(O) {\n  return {\n    equals: getEq(O).equals,\n    compare: function (x, y) {\n      return x === y ? 0 : isSome(x) ? isSome(y) ? O.compare(x.value, y.value) : 1 : -1;\n    }\n  };\n}\n/**\n * `Apply` semigroup\n *\n * | x       | y       | concat(x, y)       |\n * | ------- | ------- | ------------------ |\n * | none    | none    | none               |\n * | some(a) | none    | none               |\n * | none    | some(a) | none               |\n * | some(a) | some(b) | some(concat(a, b)) |\n *\n * @example\n * import { getApplySemigroup, some, none } from 'fp-ts/Option'\n * import { semigroupSum } from 'fp-ts/Semigroup'\n *\n * const S = getApplySemigroup(semigroupSum)\n * assert.deepStrictEqual(S.concat(none, none), none)\n * assert.deepStrictEqual(S.concat(some(1), none), none)\n * assert.deepStrictEqual(S.concat(none, some(1)), none)\n * assert.deepStrictEqual(S.concat(some(1), some(2)), some(3))\n *\n * @category instances\n * @since 2.0.0\n */\nexport function getApplySemigroup(S) {\n  return {\n    concat: function (x, y) {\n      return isSome(x) && isSome(y) ? some(S.concat(x.value, y.value)) : none;\n    }\n  };\n}\n/**\n * @category instances\n * @since 2.0.0\n */\nexport function getApplyMonoid(M) {\n  return {\n    concat: getApplySemigroup(M).concat,\n    empty: some(M.empty)\n  };\n}\n/**\n * Monoid returning the left-most non-`None` value\n *\n * | x       | y       | concat(x, y) |\n * | ------- | ------- | ------------ |\n * | none    | none    | none         |\n * | some(a) | none    | some(a)      |\n * | none    | some(a) | some(a)      |\n * | some(a) | some(b) | some(a)      |\n *\n * @example\n * import { getFirstMonoid, some, none } from 'fp-ts/Option'\n *\n * const M = getFirstMonoid<number>()\n * assert.deepStrictEqual(M.concat(none, none), none)\n * assert.deepStrictEqual(M.concat(some(1), none), some(1))\n * assert.deepStrictEqual(M.concat(none, some(1)), some(1))\n * assert.deepStrictEqual(M.concat(some(1), some(2)), some(1))\n *\n * @category instances\n * @since 2.0.0\n */\nexport function getFirstMonoid() {\n  return {\n    concat: function (x, y) {\n      return isNone(x) ? y : x;\n    },\n    empty: none\n  };\n}\n/**\n * Monoid returning the right-most non-`None` value\n *\n * | x       | y       | concat(x, y) |\n * | ------- | ------- | ------------ |\n * | none    | none    | none         |\n * | some(a) | none    | some(a)      |\n * | none    | some(a) | some(a)      |\n * | some(a) | some(b) | some(b)      |\n *\n * @example\n * import { getLastMonoid, some, none } from 'fp-ts/Option'\n *\n * const M = getLastMonoid<number>()\n * assert.deepStrictEqual(M.concat(none, none), none)\n * assert.deepStrictEqual(M.concat(some(1), none), some(1))\n * assert.deepStrictEqual(M.concat(none, some(1)), some(1))\n * assert.deepStrictEqual(M.concat(some(1), some(2)), some(2))\n *\n * @category instances\n * @since 2.0.0\n */\nexport function getLastMonoid() {\n  return {\n    concat: function (x, y) {\n      return isNone(y) ? x : y;\n    },\n    empty: none\n  };\n}\n/**\n * Monoid returning the left-most non-`None` value. If both operands are `Some`s then the inner values are\n * concatenated using the provided `Semigroup`\n *\n * | x       | y       | concat(x, y)       |\n * | ------- | ------- | ------------------ |\n * | none    | none    | none               |\n * | some(a) | none    | some(a)            |\n * | none    | some(a) | some(a)            |\n * | some(a) | some(b) | some(concat(a, b)) |\n *\n * @example\n * import { getMonoid, some, none } from 'fp-ts/Option'\n * import { semigroupSum } from 'fp-ts/Semigroup'\n *\n * const M = getMonoid(semigroupSum)\n * assert.deepStrictEqual(M.concat(none, none), none)\n * assert.deepStrictEqual(M.concat(some(1), none), some(1))\n * assert.deepStrictEqual(M.concat(none, some(1)), some(1))\n * assert.deepStrictEqual(M.concat(some(1), some(2)), some(3))\n *\n * @category instances\n * @since 2.0.0\n */\nexport function getMonoid(S) {\n  return {\n    concat: function (x, y) {\n      return isNone(x) ? y : isNone(y) ? x : some(S.concat(x.value, y.value));\n    },\n    empty: none\n  };\n}\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Functor = {\n  URI: URI,\n  map: map_\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Applicative = {\n  URI: URI,\n  map: map_,\n  ap: ap_,\n  of: of\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Monad = {\n  URI: URI,\n  map: map_,\n  ap: ap_,\n  of: of,\n  chain: chain_\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Foldable = {\n  URI: URI,\n  reduce: reduce_,\n  foldMap: foldMap_,\n  reduceRight: reduceRight_\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Alt = {\n  URI: URI,\n  map: map_,\n  alt: alt_\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Alternative = {\n  URI: URI,\n  map: map_,\n  ap: ap_,\n  of: of,\n  alt: alt_,\n  zero: zero\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Extend = {\n  URI: URI,\n  map: map_,\n  extend: extend_\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Compactable = {\n  URI: URI,\n  compact: compact,\n  separate: separate\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Filterable = {\n  URI: URI,\n  map: map_,\n  compact: compact,\n  separate: separate,\n  filter: filter_,\n  filterMap: filterMap_,\n  partition: partition_,\n  partitionMap: partitionMap_\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Traversable = {\n  URI: URI,\n  map: map_,\n  reduce: reduce_,\n  foldMap: foldMap_,\n  reduceRight: reduceRight_,\n  traverse: traverse_,\n  sequence: sequence\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Witherable = {\n  URI: URI,\n  map: map_,\n  reduce: reduce_,\n  foldMap: foldMap_,\n  reduceRight: reduceRight_,\n  traverse: traverse_,\n  sequence: sequence,\n  compact: compact,\n  separate: separate,\n  filter: filter_,\n  filterMap: filterMap_,\n  partition: partition_,\n  partitionMap: partitionMap_,\n  wither: wither_,\n  wilt: wilt_\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var MonadThrow = {\n  URI: URI,\n  map: map_,\n  ap: ap_,\n  of: of,\n  chain: chain_,\n  throwError: throwError\n};\n// TODO: remove in v3\n/**\n * @category instances\n * @since 2.0.0\n */\nexport var option = {\n  URI: URI,\n  map: map_,\n  of: of,\n  ap: ap_,\n  chain: chain_,\n  reduce: reduce_,\n  foldMap: foldMap_,\n  reduceRight: reduceRight_,\n  traverse: traverse_,\n  sequence: sequence,\n  zero: zero,\n  alt: alt_,\n  extend: extend_,\n  compact: compact,\n  separate: separate,\n  filter: filter_,\n  filterMap: filterMap_,\n  partition: partition_,\n  partitionMap: partitionMap_,\n  wither: wither_,\n  wilt: wilt_,\n  throwError: throwError\n};\n// -------------------------------------------------------------------------------------\n// utils\n// -------------------------------------------------------------------------------------\n/**\n * Returns `true` if `ma` contains `a`\n *\n * @example\n * import { some, none, elem } from 'fp-ts/Option'\n * import { eqNumber } from 'fp-ts/Eq'\n *\n * assert.strictEqual(elem(eqNumber)(1, some(1)), true)\n * assert.strictEqual(elem(eqNumber)(2, some(1)), false)\n * assert.strictEqual(elem(eqNumber)(1, none), false)\n *\n * @since 2.0.0\n */\nexport function elem(E) {\n  return function (a, ma) {\n    return isNone(ma) ? false : E.equals(a, ma.value);\n  };\n}\n/**\n * Returns `true` if the predicate is satisfied by the wrapped value\n *\n * @example\n * import { some, none, exists } from 'fp-ts/Option'\n * import { pipe } from 'fp-ts/function'\n *\n * assert.strictEqual(\n *   pipe(\n *     some(1),\n *     exists(n => n > 0)\n *   ),\n *   true\n * )\n * assert.strictEqual(\n *   pipe(\n *     some(1),\n *     exists(n => n > 1)\n *   ),\n *   false\n * )\n * assert.strictEqual(\n *   pipe(\n *     none,\n *     exists(n => n > 0)\n *   ),\n *   false\n * )\n *\n * @since 2.0.0\n */\nexport function exists(predicate) {\n  return function (ma) {\n    return isNone(ma) ? false : predicate(ma.value);\n  };\n}\n/**\n * Returns a `Refinement` (i.e. a custom type guard) from a `Option` returning function.\n * This function ensures that a custom type guard definition is type-safe.\n *\n * ```ts\n * import { some, none, getRefinement } from 'fp-ts/Option'\n *\n * type A = { type: 'A' }\n * type B = { type: 'B' }\n * type C = A | B\n *\n * const isA = (c: C): c is A => c.type === 'B' // <= typo but typescript doesn't complain\n * const isA = getRefinement<C, A>(c => (c.type === 'B' ? some(c) : none)) // static error: Type '\"B\"' is not assignable to type '\"A\"'\n * ```\n *\n * @since 2.0.0\n */\nexport function getRefinement(getOption) {\n  return function (a) {\n    return isSome(getOption(a));\n  };\n}\n// -------------------------------------------------------------------------------------\n// do notation\n// -------------------------------------------------------------------------------------\n/**\n * @since 2.9.0\n */\nexport var Do = /*#__PURE__*/\nof({});\n/**\n * @since 2.8.0\n */\nexport var bindTo = function (name) {\n  return map(bindTo_(name));\n};\n/**\n * @since 2.8.0\n */\nexport var bind = function (name, f) {\n  return chain(function (a) {\n    return pipe(f(a), map(function (b) {\n      return bind_(a, name, b);\n    }));\n  });\n};\n// -------------------------------------------------------------------------------------\n// pipeable sequence S\n// -------------------------------------------------------------------------------------\n/**\n * @since 2.8.0\n */\nexport var apS = function (name, fb) {\n  return flow(map(function (a) {\n    return function (b) {\n      return bind_(a, name, b);\n    };\n  }), ap(fb));\n};\n// -------------------------------------------------------------------------------------\n// array utils\n// -------------------------------------------------------------------------------------\n/**\n *\n * @since 2.9.0\n */\nexport var traverseArrayWithIndex = function (f) {\n  return function (arr) {\n    // tslint:disable-next-line: readonly-array\n    var result = [];\n    for (var i = 0; i < arr.length; i++) {\n      var b = f(i, arr[i]);\n      if (isNone(b)) {\n        return none;\n      }\n      result.push(b.value);\n    }\n    return some(result);\n  };\n};\n/**\n * Runs an action for every element in array and accumulates the results in option\n *\n * this function have the same behavior of `A.sequence(O.option)` but it's optimized and perform better\n *\n * @example\n *\n * import * as A from 'fp-ts/Array'\n * import { traverseArray, some, fromPredicate, none } from 'fp-ts/Option'\n * import { pipe } from 'fp-ts/function'\n *\n * const arr = A.range(0, 10)\n * assert.deepStrictEqual(pipe(arr, traverseArray(some)), some(arr))\n * assert.deepStrictEqual(pipe(arr, traverseArray(fromPredicate((x) => x > 5))), none)\n *\n * @since 2.9.0\n */\nexport var traverseArray = function (f) {\n  return traverseArrayWithIndex(function (_, a) {\n    return f(a);\n  });\n};\n/**\n * get an array of option and convert it to option of array\n *\n * this function have the same behavior of `A.sequence(O.option)` but it's optimized and perform better\n *\n * @example\n *\n * import * as A from 'fp-ts/Array'\n * import { sequenceArray, some, none, fromPredicate } from 'fp-ts/Option'\n * import { pipe } from 'fp-ts/function'\n *\n * const arr = A.range(0, 10)\n * assert.deepStrictEqual(pipe(arr, A.map(some), sequenceArray), some(arr))\n * assert.deepStrictEqual(pipe(arr, A.map(fromPredicate(x => x > 8)), sequenceArray), none)\n *\n * @since 2.9.0\n */\nexport var sequenceArray = /*#__PURE__*/\ntraverseArray(identity);","map":{"version":3,"names":["identity","pipe","bind_","bindTo_","flow","isSome","fa","_tag","isNone","none","some","a","value","fromNullable","fromPredicate","predicate","tryCatch","f","e","getLeft","ma","left","getRight","right","fromEither","fold","onNone","onSome","toNullable","toUndefined","undefined","getOrElseW","getOrElse","fromNullableK","_i","arguments","length","apply","mapNullable","chainNullableK","map_","map","ap_","fab","ap","chain_","chain","reduce_","b","reduce","foldMap_","M","foldMapM","foldMap","reduceRight_","reduceRight","traverse_","F","traverseF","traverse","ta","alt_","that","alt","filter_","filter","filterMap_","filterMap","extend_","wa","extend","partition_","partition","partitionMap_","partitionMap","wither_","witherF","wither","wilt_","wiltF","wilt","apFirst","fb","apSecond","of","chainFirst","flatten","altW","zero","throwError","duplicate","empty","compact","defaultSeparate","separate","o","sequence","URI","getShow","S","show","getEq","E","equals","x","y","getOrd","O","compare","getApplySemigroup","concat","getApplyMonoid","getFirstMonoid","getLastMonoid","getMonoid","Functor","Applicative","Monad","Foldable","Alt","Alternative","Extend","Compactable","Filterable","Traversable","Witherable","MonadThrow","option","elem","exists","getRefinement","getOption","Do","bindTo","name","bind","apS","traverseArrayWithIndex","arr","result","i","push","traverseArray","_","sequenceArray"],"sources":["/Users/arthurfrancis/Documents/repo/imx-reactjs-integration-example/node_modules/fp-ts/es6/Option.js"],"sourcesContent":["import { identity, pipe, bind_, bindTo_, flow } from './function';\n// -------------------------------------------------------------------------------------\n// guards\n// -------------------------------------------------------------------------------------\n/**\n * Returns `true` if the option is an instance of `Some`, `false` otherwise.\n *\n * @example\n * import { some, none, isSome } from 'fp-ts/Option'\n *\n * assert.strictEqual(isSome(some(1)), true)\n * assert.strictEqual(isSome(none), false)\n *\n * @category guards\n * @since 2.0.0\n */\nexport var isSome = function (fa) { return fa._tag === 'Some'; };\n/**\n * Returns `true` if the option is `None`, `false` otherwise.\n *\n * @example\n * import { some, none, isNone } from 'fp-ts/Option'\n *\n * assert.strictEqual(isNone(some(1)), false)\n * assert.strictEqual(isNone(none), true)\n *\n * @category guards\n * @since 2.0.0\n */\nexport var isNone = function (fa) { return fa._tag === 'None'; };\n// -------------------------------------------------------------------------------------\n// constructors\n// -------------------------------------------------------------------------------------\n/**\n * `None` doesn't have a constructor, instead you can use it directly as a value. Represents a missing value.\n *\n * @category constructors\n * @since 2.0.0\n */\nexport var none = { _tag: 'None' };\n/**\n * Constructs a `Some`. Represents an optional value that exists.\n *\n * @category constructors\n * @since 2.0.0\n */\nexport var some = function (a) { return ({ _tag: 'Some', value: a }); };\n/**\n * Constructs a new `Option` from a nullable type. If the value is `null` or `undefined`, returns `None`, otherwise\n * returns the value wrapped in a `Some`.\n *\n * @example\n * import { none, some, fromNullable } from 'fp-ts/Option'\n *\n * assert.deepStrictEqual(fromNullable(undefined), none)\n * assert.deepStrictEqual(fromNullable(null), none)\n * assert.deepStrictEqual(fromNullable(1), some(1))\n *\n * @category constructors\n * @since 2.0.0\n */\nexport function fromNullable(a) {\n    return a == null ? none : some(a);\n}\nexport function fromPredicate(predicate) {\n    return function (a) { return (predicate(a) ? some(a) : none); };\n}\n/**\n * Transforms an exception into an `Option`. If `f` throws, returns `None`, otherwise returns the output wrapped in a\n * `Some`.\n *\n * @example\n * import { none, some, tryCatch } from 'fp-ts/Option'\n *\n * assert.deepStrictEqual(\n *   tryCatch(() => {\n *     throw new Error()\n *   }),\n *   none\n * )\n * assert.deepStrictEqual(tryCatch(() => 1), some(1))\n *\n * @category constructors\n * @since 2.0.0\n */\nexport function tryCatch(f) {\n    try {\n        return some(f());\n    }\n    catch (e) {\n        return none;\n    }\n}\n/**\n * Returns the `Left` value of an `Either` if possible.\n *\n * @example\n * import { getLeft, none, some } from 'fp-ts/Option'\n * import { right, left } from 'fp-ts/Either'\n *\n * assert.deepStrictEqual(getLeft(right(1)), none)\n * assert.deepStrictEqual(getLeft(left('a')), some('a'))\n *\n * @category constructors\n * @since 2.0.0\n */\nexport function getLeft(ma) {\n    return ma._tag === 'Right' ? none : some(ma.left);\n}\n/**\n * Returns the `Right` value of an `Either` if possible.\n *\n * @example\n * import { getRight, none, some } from 'fp-ts/Option'\n * import { right, left } from 'fp-ts/Either'\n *\n * assert.deepStrictEqual(getRight(right(1)), some(1))\n * assert.deepStrictEqual(getRight(left('a')), none)\n *\n * @category constructors\n * @since 2.0.0\n */\nexport function getRight(ma) {\n    return ma._tag === 'Left' ? none : some(ma.right);\n}\n/**\n * Transforms an `Either` to an `Option` discarding the error.\n *\n * Alias of [getRight](#getRight)\n *\n * Derivable from `MonadThrow`.\n *\n * @category constructors\n * @since 2.0.0\n */\nexport var fromEither = getRight;\n// -------------------------------------------------------------------------------------\n// destructors\n// -------------------------------------------------------------------------------------\n/**\n * Takes a (lazy) default value, a function, and an `Option` value, if the `Option` value is `None` the default value is\n * returned, otherwise the function is applied to the value inside the `Some` and the result is returned.\n *\n * @example\n * import { some, none, fold } from 'fp-ts/Option'\n * import { pipe } from 'fp-ts/function'\n *\n * assert.strictEqual(\n *   pipe(\n *     some(1),\n *     fold(() => 'a none', a => `a some containing ${a}`)\n *   ),\n *   'a some containing 1'\n * )\n *\n * assert.strictEqual(\n *   pipe(\n *     none,\n *     fold(() => 'a none', a => `a some containing ${a}`)\n *   ),\n *   'a none'\n * )\n *\n * @category destructors\n * @since 2.0.0\n */\nexport function fold(onNone, onSome) {\n    return function (ma) { return (isNone(ma) ? onNone() : onSome(ma.value)); };\n}\n/**\n * Extracts the value out of the structure, if it exists. Otherwise returns `null`.\n *\n * @example\n * import { some, none, toNullable } from 'fp-ts/Option'\n * import { pipe } from 'fp-ts/function'\n *\n * assert.strictEqual(\n *   pipe(\n *     some(1),\n *     toNullable\n *   ),\n *   1\n * )\n * assert.strictEqual(\n *   pipe(\n *     none,\n *     toNullable\n *   ),\n *   null\n * )\n *\n * @category destructors\n * @since 2.0.0\n */\nexport function toNullable(ma) {\n    return isNone(ma) ? null : ma.value;\n}\n/**\n * Extracts the value out of the structure, if it exists. Otherwise returns `undefined`.\n *\n * @example\n * import { some, none, toUndefined } from 'fp-ts/Option'\n * import { pipe } from 'fp-ts/function'\n *\n * assert.strictEqual(\n *   pipe(\n *     some(1),\n *     toUndefined\n *   ),\n *   1\n * )\n * assert.strictEqual(\n *   pipe(\n *     none,\n *     toUndefined\n *   ),\n *   undefined\n * )\n *\n * @category destructors\n * @since 2.0.0\n */\nexport function toUndefined(ma) {\n    return isNone(ma) ? undefined : ma.value;\n}\n/**\n * Less strict version of [`getOrElse`](#getOrElse).\n *\n * @category destructors\n * @since 2.6.0\n */\nexport var getOrElseW = function (onNone) { return function (ma) { return (isNone(ma) ? onNone() : ma.value); }; };\n/**\n * Extracts the value out of the structure, if it exists. Otherwise returns the given default value\n *\n * @example\n * import { some, none, getOrElse } from 'fp-ts/Option'\n * import { pipe } from 'fp-ts/function'\n *\n * assert.strictEqual(\n *   pipe(\n *     some(1),\n *     getOrElse(() => 0)\n *   ),\n *   1\n * )\n * assert.strictEqual(\n *   pipe(\n *     none,\n *     getOrElse(() => 0)\n *   ),\n *   0\n * )\n *\n * @category destructors\n * @since 2.0.0\n */\nexport var getOrElse = getOrElseW;\n// -------------------------------------------------------------------------------------\n// combinators\n// -------------------------------------------------------------------------------------\n/**\n * Returns a *smart constructor* from a function that returns a nullable value.\n *\n * @example\n * import { fromNullableK, none, some } from 'fp-ts/Option'\n *\n * const f = (s: string): number | undefined => {\n *   const n = parseFloat(s)\n *   return isNaN(n) ? undefined : n\n * }\n *\n * const g = fromNullableK(f)\n *\n * assert.deepStrictEqual(g('1'), some(1))\n * assert.deepStrictEqual(g('a'), none)\n *\n * @category combinators\n * @since 2.9.0\n */\nexport function fromNullableK(f) {\n    return function () {\n        var a = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            a[_i] = arguments[_i];\n        }\n        return fromNullable(f.apply(void 0, a));\n    };\n}\n/**\n * @category combinators\n * @since 2.0.0\n * @deprecated\n */\nexport var mapNullable = chainNullableK;\n/**\n * This is `chain` + `fromNullable`, useful when working with optional values.\n *\n * @example\n * import { some, none, fromNullable, chainNullableK } from 'fp-ts/Option'\n * import { pipe } from 'fp-ts/function'\n *\n * interface Employee {\n *   company?: {\n *     address?: {\n *       street?: {\n *         name?: string\n *       }\n *     }\n *   }\n * }\n *\n * const employee1: Employee = { company: { address: { street: { name: 'high street' } } } }\n *\n * assert.deepStrictEqual(\n *   pipe(\n *     fromNullable(employee1.company),\n *     chainNullableK(company => company.address),\n *     chainNullableK(address => address.street),\n *     chainNullableK(street => street.name)\n *   ),\n *   some('high street')\n * )\n *\n * const employee2: Employee = { company: { address: { street: {} } } }\n *\n * assert.deepStrictEqual(\n *   pipe(\n *     fromNullable(employee2.company),\n *     chainNullableK(company => company.address),\n *     chainNullableK(address => address.street),\n *     chainNullableK(street => street.name)\n *   ),\n *   none\n * )\n *\n * @category combinators\n * @since 2.9.0\n */\nexport function chainNullableK(f) {\n    return function (ma) { return (isNone(ma) ? none : fromNullable(f(ma.value))); };\n}\n// -------------------------------------------------------------------------------------\n// non-pipeables\n// -------------------------------------------------------------------------------------\nvar map_ = function (fa, f) { return pipe(fa, map(f)); };\nvar ap_ = function (fab, fa) { return pipe(fab, ap(fa)); };\nvar chain_ = function (ma, f) { return pipe(ma, chain(f)); };\nvar reduce_ = function (fa, b, f) { return pipe(fa, reduce(b, f)); };\nvar foldMap_ = function (M) {\n    var foldMapM = foldMap(M);\n    return function (fa, f) { return pipe(fa, foldMapM(f)); };\n};\nvar reduceRight_ = function (fa, b, f) { return pipe(fa, reduceRight(b, f)); };\nvar traverse_ = function (F) {\n    var traverseF = traverse(F);\n    return function (ta, f) { return pipe(ta, traverseF(f)); };\n};\n/* istanbul ignore next */\nvar alt_ = function (fa, that) { return pipe(fa, alt(that)); };\nvar filter_ = function (fa, predicate) {\n    return pipe(fa, filter(predicate));\n};\n/* istanbul ignore next */\nvar filterMap_ = function (fa, f) { return pipe(fa, filterMap(f)); };\n/* istanbul ignore next */\nvar extend_ = function (wa, f) { return pipe(wa, extend(f)); };\n/* istanbul ignore next */\nvar partition_ = function (fa, predicate) { return pipe(fa, partition(predicate)); };\n/* istanbul ignore next */\nvar partitionMap_ = function (fa, f) { return pipe(fa, partitionMap(f)); };\n/* istanbul ignore next */\nvar wither_ = function (F) {\n    var witherF = wither(F);\n    return function (fa, f) { return pipe(fa, witherF(f)); };\n};\n/* istanbul ignore next */\nvar wilt_ = function (F) {\n    var wiltF = wilt(F);\n    return function (fa, f) { return pipe(fa, wiltF(f)); };\n};\n// -------------------------------------------------------------------------------------\n// pipeables\n// -------------------------------------------------------------------------------------\n/**\n * `map` can be used to turn functions `(a: A) => B` into functions `(fa: F<A>) => F<B>` whose argument and return types\n * use the type constructor `F` to represent some computational context.\n *\n * @category Functor\n * @since 2.0.0\n */\nexport var map = function (f) { return function (fa) {\n    return isNone(fa) ? none : some(f(fa.value));\n}; };\n/**\n * Apply a function to an argument under a type constructor.\n *\n * @category Apply\n * @since 2.0.0\n */\nexport var ap = function (fa) { return function (fab) {\n    return isNone(fab) ? none : isNone(fa) ? none : some(fab.value(fa.value));\n}; };\n/**\n * Combine two effectful actions, keeping only the result of the first.\n *\n * Derivable from `Apply`.\n *\n * @category combinators\n * @since 2.0.0\n */\nexport var apFirst = function (fb) {\n    return flow(map(function (a) { return function () { return a; }; }), ap(fb));\n};\n/**\n * Combine two effectful actions, keeping only the result of the second.\n *\n * Derivable from `Apply`.\n *\n * @category combinators\n * @since 2.0.0\n */\nexport var apSecond = function (fb) {\n    return flow(map(function () { return function (b) { return b; }; }), ap(fb));\n};\n/**\n * Wrap a value into the type constructor.\n *\n * @category Applicative\n * @since 2.7.0\n */\nexport var of = some;\n/**\n * Composes computations in sequence, using the return value of one computation to determine the next computation.\n *\n * @category Monad\n * @since 2.0.0\n */\nexport var chain = function (f) { return function (ma) {\n    return isNone(ma) ? none : f(ma.value);\n}; };\n/**\n * Composes computations in sequence, using the return value of one computation to determine the next computation and\n * keeping only the result of the first.\n *\n * Derivable from `Monad`.\n *\n * @category combinators\n * @since 2.0.0\n */\nexport var chainFirst = function (f) {\n    return chain(function (a) {\n        return pipe(f(a), map(function () { return a; }));\n    });\n};\n/**\n * Derivable from `Monad`.\n *\n * @category combinators\n * @since 2.0.0\n */\nexport var flatten = \n/*#__PURE__*/\nchain(identity);\n/**\n * Less strict version of [`alt`](#alt).\n *\n * @category Alt\n * @since 2.9.0\n */\nexport var altW = function (that) { return function (fa) {\n    return isNone(fa) ? that() : fa;\n}; };\n/**\n * Identifies an associative operation on a type constructor. It is similar to `Semigroup`, except that it applies to\n * types of kind `* -> *`.\n *\n * In case of `Option` returns the left-most non-`None` value.\n *\n * @example\n * import * as O from 'fp-ts/Option'\n * import { pipe } from 'fp-ts/function'\n *\n * assert.deepStrictEqual(\n *   pipe(\n *     O.some('a'),\n *     O.alt(() => O.some('b'))\n *   ),\n *   O.some('a')\n * )\n * assert.deepStrictEqual(\n *   pipe(\n *     O.none,\n *     O.alt(() => O.some('b'))\n *   ),\n *   O.some('b')\n * )\n *\n * @category Alt\n * @since 2.0.0\n */\nexport var alt = altW;\n/**\n * @category Alternative\n * @since 2.7.0\n */\nexport var zero = function () { return none; };\n/**\n * @category MonadThrow\n * @since 2.7.0\n */\nexport var throwError = function () { return none; };\n/**\n * @category Extend\n * @since 2.0.0\n */\nexport var extend = function (f) { return function (wa) {\n    return isNone(wa) ? none : some(f(wa));\n}; };\n/**\n * Derivable from `Extend`.\n *\n * @category combinators\n * @since 2.0.0\n */\nexport var duplicate = \n/*#__PURE__*/\nextend(identity);\n/**\n * @category Foldable\n * @since 2.0.0\n */\nexport var reduce = function (b, f) { return function (fa) {\n    return isNone(fa) ? b : f(b, fa.value);\n}; };\n/**\n * @category Foldable\n * @since 2.0.0\n */\nexport var foldMap = function (M) { return function (f) { return function (fa) {\n    return isNone(fa) ? M.empty : f(fa.value);\n}; }; };\n/**\n * @category Foldable\n * @since 2.0.0\n */\nexport var reduceRight = function (b, f) { return function (fa) {\n    return isNone(fa) ? b : f(fa.value, b);\n}; };\n/**\n * @category Compactable\n * @since 2.0.0\n */\nexport var compact = flatten;\nvar defaultSeparate = { left: none, right: none };\n/**\n * @category Compactable\n * @since 2.0.0\n */\nexport var separate = function (ma) {\n    var o = pipe(ma, map(function (e) { return ({\n        left: getLeft(e),\n        right: getRight(e)\n    }); }));\n    return isNone(o) ? defaultSeparate : o.value;\n};\n/**\n * @category Filterable\n * @since 2.0.0\n */\nexport var filter = function (predicate) { return function (fa) { return (isNone(fa) ? none : predicate(fa.value) ? fa : none); }; };\n/**\n * @category Filterable\n * @since 2.0.0\n */\nexport var filterMap = function (f) { return function (fa) {\n    return isNone(fa) ? none : f(fa.value);\n}; };\n/**\n * @category Filterable\n * @since 2.0.0\n */\nexport var partition = function (predicate) { return function (fa) {\n    return {\n        left: filter_(fa, function (a) { return !predicate(a); }),\n        right: filter_(fa, predicate)\n    };\n}; };\n/**\n * @category Filterable\n * @since 2.0.0\n */\nexport var partitionMap = function (f) { return flow(map(f), separate); };\n/**\n * @category Traversable\n * @since 2.6.3\n */\nexport var traverse = function (F) { return function (f) { return function (ta) { return (isNone(ta) ? F.of(none) : F.map(f(ta.value), some)); }; }; };\n/**\n * @category Traversable\n * @since 2.6.3\n */\nexport var sequence = function (F) { return function (ta) { return (isNone(ta) ? F.of(none) : F.map(ta.value, some)); }; };\n/**\n * @category Witherable\n * @since 2.6.5\n */\nexport var wither = function (F) { return function (f) { return function (fa) { return (isNone(fa) ? F.of(none) : f(fa.value)); }; }; };\n/**\n * @category Witherable\n * @since 2.6.5\n */\nexport var wilt = function (F) { return function (f) { return function (fa) {\n    return isNone(fa)\n        ? F.of({\n            left: none,\n            right: none\n        })\n        : F.map(f(fa.value), function (e) { return ({\n            left: getLeft(e),\n            right: getRight(e)\n        }); });\n}; }; };\n// -------------------------------------------------------------------------------------\n// instances\n// -------------------------------------------------------------------------------------\n/**\n * @category instances\n * @since 2.0.0\n */\nexport var URI = 'Option';\n/**\n * @category instances\n * @since 2.0.0\n */\nexport function getShow(S) {\n    return {\n        show: function (ma) { return (isNone(ma) ? 'none' : \"some(\" + S.show(ma.value) + \")\"); }\n    };\n}\n/**\n * @example\n * import { none, some, getEq } from 'fp-ts/Option'\n * import { eqNumber } from 'fp-ts/Eq'\n *\n * const E = getEq(eqNumber)\n * assert.strictEqual(E.equals(none, none), true)\n * assert.strictEqual(E.equals(none, some(1)), false)\n * assert.strictEqual(E.equals(some(1), none), false)\n * assert.strictEqual(E.equals(some(1), some(2)), false)\n * assert.strictEqual(E.equals(some(1), some(1)), true)\n *\n * @category instances\n * @since 2.0.0\n */\nexport function getEq(E) {\n    return {\n        equals: function (x, y) { return x === y || (isNone(x) ? isNone(y) : isNone(y) ? false : E.equals(x.value, y.value)); }\n    };\n}\n/**\n * The `Ord` instance allows `Option` values to be compared with\n * `compare`, whenever there is an `Ord` instance for\n * the type the `Option` contains.\n *\n * `None` is considered to be less than any `Some` value.\n *\n *\n * @example\n * import { none, some, getOrd } from 'fp-ts/Option'\n * import { ordNumber } from 'fp-ts/Ord'\n *\n * const O = getOrd(ordNumber)\n * assert.strictEqual(O.compare(none, none), 0)\n * assert.strictEqual(O.compare(none, some(1)), -1)\n * assert.strictEqual(O.compare(some(1), none), 1)\n * assert.strictEqual(O.compare(some(1), some(2)), -1)\n * assert.strictEqual(O.compare(some(1), some(1)), 0)\n *\n * @category instances\n * @since 2.0.0\n */\nexport function getOrd(O) {\n    return {\n        equals: getEq(O).equals,\n        compare: function (x, y) { return (x === y ? 0 : isSome(x) ? (isSome(y) ? O.compare(x.value, y.value) : 1) : -1); }\n    };\n}\n/**\n * `Apply` semigroup\n *\n * | x       | y       | concat(x, y)       |\n * | ------- | ------- | ------------------ |\n * | none    | none    | none               |\n * | some(a) | none    | none               |\n * | none    | some(a) | none               |\n * | some(a) | some(b) | some(concat(a, b)) |\n *\n * @example\n * import { getApplySemigroup, some, none } from 'fp-ts/Option'\n * import { semigroupSum } from 'fp-ts/Semigroup'\n *\n * const S = getApplySemigroup(semigroupSum)\n * assert.deepStrictEqual(S.concat(none, none), none)\n * assert.deepStrictEqual(S.concat(some(1), none), none)\n * assert.deepStrictEqual(S.concat(none, some(1)), none)\n * assert.deepStrictEqual(S.concat(some(1), some(2)), some(3))\n *\n * @category instances\n * @since 2.0.0\n */\nexport function getApplySemigroup(S) {\n    return {\n        concat: function (x, y) { return (isSome(x) && isSome(y) ? some(S.concat(x.value, y.value)) : none); }\n    };\n}\n/**\n * @category instances\n * @since 2.0.0\n */\nexport function getApplyMonoid(M) {\n    return {\n        concat: getApplySemigroup(M).concat,\n        empty: some(M.empty)\n    };\n}\n/**\n * Monoid returning the left-most non-`None` value\n *\n * | x       | y       | concat(x, y) |\n * | ------- | ------- | ------------ |\n * | none    | none    | none         |\n * | some(a) | none    | some(a)      |\n * | none    | some(a) | some(a)      |\n * | some(a) | some(b) | some(a)      |\n *\n * @example\n * import { getFirstMonoid, some, none } from 'fp-ts/Option'\n *\n * const M = getFirstMonoid<number>()\n * assert.deepStrictEqual(M.concat(none, none), none)\n * assert.deepStrictEqual(M.concat(some(1), none), some(1))\n * assert.deepStrictEqual(M.concat(none, some(1)), some(1))\n * assert.deepStrictEqual(M.concat(some(1), some(2)), some(1))\n *\n * @category instances\n * @since 2.0.0\n */\nexport function getFirstMonoid() {\n    return {\n        concat: function (x, y) { return (isNone(x) ? y : x); },\n        empty: none\n    };\n}\n/**\n * Monoid returning the right-most non-`None` value\n *\n * | x       | y       | concat(x, y) |\n * | ------- | ------- | ------------ |\n * | none    | none    | none         |\n * | some(a) | none    | some(a)      |\n * | none    | some(a) | some(a)      |\n * | some(a) | some(b) | some(b)      |\n *\n * @example\n * import { getLastMonoid, some, none } from 'fp-ts/Option'\n *\n * const M = getLastMonoid<number>()\n * assert.deepStrictEqual(M.concat(none, none), none)\n * assert.deepStrictEqual(M.concat(some(1), none), some(1))\n * assert.deepStrictEqual(M.concat(none, some(1)), some(1))\n * assert.deepStrictEqual(M.concat(some(1), some(2)), some(2))\n *\n * @category instances\n * @since 2.0.0\n */\nexport function getLastMonoid() {\n    return {\n        concat: function (x, y) { return (isNone(y) ? x : y); },\n        empty: none\n    };\n}\n/**\n * Monoid returning the left-most non-`None` value. If both operands are `Some`s then the inner values are\n * concatenated using the provided `Semigroup`\n *\n * | x       | y       | concat(x, y)       |\n * | ------- | ------- | ------------------ |\n * | none    | none    | none               |\n * | some(a) | none    | some(a)            |\n * | none    | some(a) | some(a)            |\n * | some(a) | some(b) | some(concat(a, b)) |\n *\n * @example\n * import { getMonoid, some, none } from 'fp-ts/Option'\n * import { semigroupSum } from 'fp-ts/Semigroup'\n *\n * const M = getMonoid(semigroupSum)\n * assert.deepStrictEqual(M.concat(none, none), none)\n * assert.deepStrictEqual(M.concat(some(1), none), some(1))\n * assert.deepStrictEqual(M.concat(none, some(1)), some(1))\n * assert.deepStrictEqual(M.concat(some(1), some(2)), some(3))\n *\n * @category instances\n * @since 2.0.0\n */\nexport function getMonoid(S) {\n    return {\n        concat: function (x, y) { return (isNone(x) ? y : isNone(y) ? x : some(S.concat(x.value, y.value))); },\n        empty: none\n    };\n}\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Functor = {\n    URI: URI,\n    map: map_\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Applicative = {\n    URI: URI,\n    map: map_,\n    ap: ap_,\n    of: of\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Monad = {\n    URI: URI,\n    map: map_,\n    ap: ap_,\n    of: of,\n    chain: chain_\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Foldable = {\n    URI: URI,\n    reduce: reduce_,\n    foldMap: foldMap_,\n    reduceRight: reduceRight_\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Alt = {\n    URI: URI,\n    map: map_,\n    alt: alt_\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Alternative = {\n    URI: URI,\n    map: map_,\n    ap: ap_,\n    of: of,\n    alt: alt_,\n    zero: zero\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Extend = {\n    URI: URI,\n    map: map_,\n    extend: extend_\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Compactable = {\n    URI: URI,\n    compact: compact,\n    separate: separate\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Filterable = {\n    URI: URI,\n    map: map_,\n    compact: compact,\n    separate: separate,\n    filter: filter_,\n    filterMap: filterMap_,\n    partition: partition_,\n    partitionMap: partitionMap_\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Traversable = {\n    URI: URI,\n    map: map_,\n    reduce: reduce_,\n    foldMap: foldMap_,\n    reduceRight: reduceRight_,\n    traverse: traverse_,\n    sequence: sequence\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Witherable = {\n    URI: URI,\n    map: map_,\n    reduce: reduce_,\n    foldMap: foldMap_,\n    reduceRight: reduceRight_,\n    traverse: traverse_,\n    sequence: sequence,\n    compact: compact,\n    separate: separate,\n    filter: filter_,\n    filterMap: filterMap_,\n    partition: partition_,\n    partitionMap: partitionMap_,\n    wither: wither_,\n    wilt: wilt_\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var MonadThrow = {\n    URI: URI,\n    map: map_,\n    ap: ap_,\n    of: of,\n    chain: chain_,\n    throwError: throwError\n};\n// TODO: remove in v3\n/**\n * @category instances\n * @since 2.0.0\n */\nexport var option = {\n    URI: URI,\n    map: map_,\n    of: of,\n    ap: ap_,\n    chain: chain_,\n    reduce: reduce_,\n    foldMap: foldMap_,\n    reduceRight: reduceRight_,\n    traverse: traverse_,\n    sequence: sequence,\n    zero: zero,\n    alt: alt_,\n    extend: extend_,\n    compact: compact,\n    separate: separate,\n    filter: filter_,\n    filterMap: filterMap_,\n    partition: partition_,\n    partitionMap: partitionMap_,\n    wither: wither_,\n    wilt: wilt_,\n    throwError: throwError\n};\n// -------------------------------------------------------------------------------------\n// utils\n// -------------------------------------------------------------------------------------\n/**\n * Returns `true` if `ma` contains `a`\n *\n * @example\n * import { some, none, elem } from 'fp-ts/Option'\n * import { eqNumber } from 'fp-ts/Eq'\n *\n * assert.strictEqual(elem(eqNumber)(1, some(1)), true)\n * assert.strictEqual(elem(eqNumber)(2, some(1)), false)\n * assert.strictEqual(elem(eqNumber)(1, none), false)\n *\n * @since 2.0.0\n */\nexport function elem(E) {\n    return function (a, ma) { return (isNone(ma) ? false : E.equals(a, ma.value)); };\n}\n/**\n * Returns `true` if the predicate is satisfied by the wrapped value\n *\n * @example\n * import { some, none, exists } from 'fp-ts/Option'\n * import { pipe } from 'fp-ts/function'\n *\n * assert.strictEqual(\n *   pipe(\n *     some(1),\n *     exists(n => n > 0)\n *   ),\n *   true\n * )\n * assert.strictEqual(\n *   pipe(\n *     some(1),\n *     exists(n => n > 1)\n *   ),\n *   false\n * )\n * assert.strictEqual(\n *   pipe(\n *     none,\n *     exists(n => n > 0)\n *   ),\n *   false\n * )\n *\n * @since 2.0.0\n */\nexport function exists(predicate) {\n    return function (ma) { return (isNone(ma) ? false : predicate(ma.value)); };\n}\n/**\n * Returns a `Refinement` (i.e. a custom type guard) from a `Option` returning function.\n * This function ensures that a custom type guard definition is type-safe.\n *\n * ```ts\n * import { some, none, getRefinement } from 'fp-ts/Option'\n *\n * type A = { type: 'A' }\n * type B = { type: 'B' }\n * type C = A | B\n *\n * const isA = (c: C): c is A => c.type === 'B' // <= typo but typescript doesn't complain\n * const isA = getRefinement<C, A>(c => (c.type === 'B' ? some(c) : none)) // static error: Type '\"B\"' is not assignable to type '\"A\"'\n * ```\n *\n * @since 2.0.0\n */\nexport function getRefinement(getOption) {\n    return function (a) { return isSome(getOption(a)); };\n}\n// -------------------------------------------------------------------------------------\n// do notation\n// -------------------------------------------------------------------------------------\n/**\n * @since 2.9.0\n */\nexport var Do = \n/*#__PURE__*/\nof({});\n/**\n * @since 2.8.0\n */\nexport var bindTo = function (name) { return map(bindTo_(name)); };\n/**\n * @since 2.8.0\n */\nexport var bind = function (name, f) {\n    return chain(function (a) {\n        return pipe(f(a), map(function (b) { return bind_(a, name, b); }));\n    });\n};\n// -------------------------------------------------------------------------------------\n// pipeable sequence S\n// -------------------------------------------------------------------------------------\n/**\n * @since 2.8.0\n */\nexport var apS = function (name, fb) {\n    return flow(map(function (a) { return function (b) { return bind_(a, name, b); }; }), ap(fb));\n};\n// -------------------------------------------------------------------------------------\n// array utils\n// -------------------------------------------------------------------------------------\n/**\n *\n * @since 2.9.0\n */\nexport var traverseArrayWithIndex = function (f) { return function (arr) {\n    // tslint:disable-next-line: readonly-array\n    var result = [];\n    for (var i = 0; i < arr.length; i++) {\n        var b = f(i, arr[i]);\n        if (isNone(b)) {\n            return none;\n        }\n        result.push(b.value);\n    }\n    return some(result);\n}; };\n/**\n * Runs an action for every element in array and accumulates the results in option\n *\n * this function have the same behavior of `A.sequence(O.option)` but it's optimized and perform better\n *\n * @example\n *\n * import * as A from 'fp-ts/Array'\n * import { traverseArray, some, fromPredicate, none } from 'fp-ts/Option'\n * import { pipe } from 'fp-ts/function'\n *\n * const arr = A.range(0, 10)\n * assert.deepStrictEqual(pipe(arr, traverseArray(some)), some(arr))\n * assert.deepStrictEqual(pipe(arr, traverseArray(fromPredicate((x) => x > 5))), none)\n *\n * @since 2.9.0\n */\nexport var traverseArray = function (f) { return traverseArrayWithIndex(function (_, a) { return f(a); }); };\n/**\n * get an array of option and convert it to option of array\n *\n * this function have the same behavior of `A.sequence(O.option)` but it's optimized and perform better\n *\n * @example\n *\n * import * as A from 'fp-ts/Array'\n * import { sequenceArray, some, none, fromPredicate } from 'fp-ts/Option'\n * import { pipe } from 'fp-ts/function'\n *\n * const arr = A.range(0, 10)\n * assert.deepStrictEqual(pipe(arr, A.map(some), sequenceArray), some(arr))\n * assert.deepStrictEqual(pipe(arr, A.map(fromPredicate(x => x > 8)), sequenceArray), none)\n *\n * @since 2.9.0\n */\nexport var sequenceArray = \n/*#__PURE__*/\ntraverseArray(identity);\n"],"mappings":"AAAA,SAASA,QAAQ,EAAEC,IAAI,EAAEC,KAAK,EAAEC,OAAO,EAAEC,IAAI,QAAQ,YAAY;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,IAAIC,MAAM,GAAG,UAAUC,EAAE,EAAE;EAAE,OAAOA,EAAE,CAACC,IAAI,KAAK,MAAM;AAAE,CAAC;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,IAAIC,MAAM,GAAG,UAAUF,EAAE,EAAE;EAAE,OAAOA,EAAE,CAACC,IAAI,KAAK,MAAM;AAAE,CAAC;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,IAAIE,IAAI,GAAG;EAAEF,IAAI,EAAE;AAAO,CAAC;AAClC;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,IAAIG,IAAI,GAAG,UAAUC,CAAC,EAAE;EAAE,OAAQ;IAAEJ,IAAI,EAAE,MAAM;IAAEK,KAAK,EAAED;EAAE,CAAC;AAAG,CAAC;AACvE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASE,YAAY,CAACF,CAAC,EAAE;EAC5B,OAAOA,CAAC,IAAI,IAAI,GAAGF,IAAI,GAAGC,IAAI,CAACC,CAAC,CAAC;AACrC;AACA,OAAO,SAASG,aAAa,CAACC,SAAS,EAAE;EACrC,OAAO,UAAUJ,CAAC,EAAE;IAAE,OAAQI,SAAS,CAACJ,CAAC,CAAC,GAAGD,IAAI,CAACC,CAAC,CAAC,GAAGF,IAAI;EAAG,CAAC;AACnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASO,QAAQ,CAACC,CAAC,EAAE;EACxB,IAAI;IACA,OAAOP,IAAI,CAACO,CAAC,EAAE,CAAC;EACpB,CAAC,CACD,OAAOC,CAAC,EAAE;IACN,OAAOT,IAAI;EACf;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASU,OAAO,CAACC,EAAE,EAAE;EACxB,OAAOA,EAAE,CAACb,IAAI,KAAK,OAAO,GAAGE,IAAI,GAAGC,IAAI,CAACU,EAAE,CAACC,IAAI,CAAC;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASC,QAAQ,CAACF,EAAE,EAAE;EACzB,OAAOA,EAAE,CAACb,IAAI,KAAK,MAAM,GAAGE,IAAI,GAAGC,IAAI,CAACU,EAAE,CAACG,KAAK,CAAC;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,IAAIC,UAAU,GAAGF,QAAQ;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASG,IAAI,CAACC,MAAM,EAAEC,MAAM,EAAE;EACjC,OAAO,UAAUP,EAAE,EAAE;IAAE,OAAQZ,MAAM,CAACY,EAAE,CAAC,GAAGM,MAAM,EAAE,GAAGC,MAAM,CAACP,EAAE,CAACR,KAAK,CAAC;EAAG,CAAC;AAC/E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASgB,UAAU,CAACR,EAAE,EAAE;EAC3B,OAAOZ,MAAM,CAACY,EAAE,CAAC,GAAG,IAAI,GAAGA,EAAE,CAACR,KAAK;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASiB,WAAW,CAACT,EAAE,EAAE;EAC5B,OAAOZ,MAAM,CAACY,EAAE,CAAC,GAAGU,SAAS,GAAGV,EAAE,CAACR,KAAK;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,IAAImB,UAAU,GAAG,UAAUL,MAAM,EAAE;EAAE,OAAO,UAAUN,EAAE,EAAE;IAAE,OAAQZ,MAAM,CAACY,EAAE,CAAC,GAAGM,MAAM,EAAE,GAAGN,EAAE,CAACR,KAAK;EAAG,CAAC;AAAE,CAAC;AAClH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,IAAIoB,SAAS,GAAGD,UAAU;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASE,aAAa,CAAChB,CAAC,EAAE;EAC7B,OAAO,YAAY;IACf,IAAIN,CAAC,GAAG,EAAE;IACV,KAAK,IAAIuB,EAAE,GAAG,CAAC,EAAEA,EAAE,GAAGC,SAAS,CAACC,MAAM,EAAEF,EAAE,EAAE,EAAE;MAC1CvB,CAAC,CAACuB,EAAE,CAAC,GAAGC,SAAS,CAACD,EAAE,CAAC;IACzB;IACA,OAAOrB,YAAY,CAACI,CAAC,CAACoB,KAAK,CAAC,KAAK,CAAC,EAAE1B,CAAC,CAAC,CAAC;EAC3C,CAAC;AACL;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,IAAI2B,WAAW,GAAGC,cAAc;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASA,cAAc,CAACtB,CAAC,EAAE;EAC9B,OAAO,UAAUG,EAAE,EAAE;IAAE,OAAQZ,MAAM,CAAC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AAc,CAAC5D,CAAC,EAAE;EAC9B,OAAO;IACH2D,MAAM,EAAED,iBAAiB,CAAC1D,CAAC,CAAC,CAAC2D,MAAM;IACnCnB,KAAK,EAAEjF,IAAI,CAACyC,CAAC,CAACwC,KAAK;EACvB,CAAC;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASqB,cAAc,GAAG;EAC7B,OAAO;IACHF,MAAM,EAAE,UAAUN,CAAC,EAAEC,CAAC,EAAE;MAAE,OAAQjG,MAAM,CAACgG,CAAC,CAAC,GAAGC,CAAC,GAAGD,CAAC;IAAG,CAAC;IACvDb,KAAK,EAAElF;EACX,CAAC;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASwG,aAAa,GAAG;EAC5B,OAAO;IACHH,MAAM,EAAE,UAAUN,CAAC,EAAEC,CAAC,EAAE;MAAE,OAAQjG,MAAM,CAACiG,CAAC,CAAC,GAAGD,CAAC,GAAGC,CAAC;IAAG,CAAC;IACvDd,KAAK,EAAElF;EACX,CAAC;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASyG,SAAS,CAACf,CAAC,EAAE;EACzB,OAAO;IACHW,MAAM,EAAE,UAAUN,CAAC,EAAEC,CAAC,EAAE;MAAE,OAAQjG,MAAM,CAACgG,CAAC,CAAC,GAAGC,CAAC,GAAGjG,MAAM,CAACiG,CAAC,CAAC,GAAGD,CAAC,GAAG9F,IAAI,CAACyF,CAAC,CAACW,MAAM,CAACN,CAAC,CAAC5F,KAAK,EAAE6F,CAAC,CAAC7F,KAAK,CAAC,CAAC;IAAG,CAAC;IACtG+E,KAAK,EAAElF;EACX,CAAC;AACL;AACA;AACA;AACA;AACA;AACA,OAAO,IAA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,IAAI,EAAEA,IAAI;EACVzB,GAAG,EAAEF,IAAI;EACTS,MAAM,EAAEF,OAAO;EACfwB,OAAO,EAAEA,OAAO;EAChBE,QAAQ,EAAEA,QAAQ;EAClB7B,MAAM,EAAED,OAAO;EACfG,SAAS,EAAED,UAAU;EACrBM,SAAS,EAAED,UAAU;EACrBG,YAAY,EAAED,aAAa;EAC3BI,MAAM,EAAEF,OAAO;EACfK,IAAI,EAAEF,KAAK;EACXW,UAAU,EAAEA;AAChB,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASuC,IAAI,CAAC1B,CAAC,EAAE;EACpB,OAAO,UAAU3F,CAAC,EAAES,EAAE,EAAE;IAAE,OAAQZ,MAAM,CAACY,EAAE,CAAC,GAAG,KAAK,GAAGkF,CAAC,CAACC,MAAM,CAAC5F,CAAC,EAAES,EAAE,CAACR,KAAK,CAAC;EAAG,CAAC;AACpF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASqH,MAAM,CAAClH,SAAS,EAAE;EAC9B,OAAO,UAAUK,EAAE,EAAE;IAAE,OAAQZ,MAAM,CAACY,EAAE,CAAC,GAAG,KAAK,GAAGL,SAAS,CAACK,EAAE,CAACR,KAAK,CAAC;EAAG,CAAC;AAC/E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASsH,aAAa,CAACC,SAAS,EAAE;EACrC,OAAO,UAAUxH,CAAC,EAAE;IAAE,OAAON,MAAM,CAAC8H,SAAS,CAACxH,CAAC,CAAC,CAAC;EAAE,CAAC;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,IAAIyH,EAAE,GACb;AACAhD,EAAE,CAAC,CAAC,CAAC,CAAC;AACN;AACA;AACA;AACA,OAAO,IAAIiD,MAAM,GAAG,UAAUC,IAAI,EAAE;EAAE,OAAO7F,GAAG,CAACtC,OAAO,CAACmI,IAAI,CAAC,CAAC;AAAE,CAAC;AAClE;AACA;AACA;AACA,OAAO,IAAIC,IAAI,GAAG,UAAUD,IAAI,EAAErH,CAAC,EAAE;EACjC,OAAO6B,KAAK,CAAC,UAAUnC,CAAC,EAAE;IACtB,OAAOV,IAAI,CAACgB,CAAC,CAACN,CAAC,CAAC,EAAE8B,GAAG,CAAC,UAAUO,CAAC,EAAE;MAAE,OAAO9C,KAAK,CAACS,CAAC,EAAE2H,IAAI,EAAEtF,CAAC,CAAC;IAAE,CAAC,CAAC,CAAC;EACtE,CAAC,CAAC;AACN,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,IAAIwF,GAAG,GAAG,UAAUF,IAAI,EAAEpD,EAAE,EAAE;EACjC,OAAO9E,IAAI,CAACqC,GAAG,CAAC,UAAU9B,CAAC,EAAE;IAAE,OAAO,UAAUqC,CAAC,EAAE;MAAE,OAAO9C,KAAK,CAACS,CAAC,EAAE2H,IAAI,EAAEtF,CAAC,CAAC;IAAE,CAAC;EAAE,CAAC,CAAC,EAAEJ,EAAE,CAACsC,EAAE,CAAC,CAAC;AACjG,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,IAAIuD,sBAAsB,GAAG,UAAUxH,CAAC,EAAE;EAAE,OAAO,UAAUyH,GAAG,EAAE;IACrE;IACA,IAAIC,MAAM,GAAG,EAAE;IACf,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGF,GAAG,CAACtG,MAAM,EAAEwG,CAAC,EAAE,EAAE;MACjC,IAAI5F,CAAC,GAAG/B,CAAC,CAAC2H,CAAC,EAAEF,GAAG,CAACE,CAAC,CAAC,CAAC;MACpB,IAAIpI,MAAM,CAACwC,CAAC,CAAC,EAAE;QACX,OAAOvC,IAAI;MACf;MACAkI,MAAM,CAACE,IAAI,CAAC7F,CAAC,CAACpC,KAAK,CAAC;IACxB;IACA,OAAOF,IAAI,CAACiI,MAAM,CAAC;EACvB,CAAC;AAAE,CAAC;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,IAAIG,aAAa,GAAG,UAAU7H,CAAC,EAAE;EAAE,OAAOwH,sBAAsB,CAAC,UAAUM,CAAC,EAAEpI,CAAC,EAAE;IAAE,OAAOM,CAAC,CAACN,CAAC,CAAC;EAAE,CAAC,CAAC;AAAE,CAAC;AAC5G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,IAAIqI,aAAa,GACxB;AACAF,aAAa,CAAC9I,QAAQ,CAAC"},"metadata":{},"sourceType":"module"}