{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nconst is_typedarray_1 = __importDefault(require(\"is-typedarray\"));\nconst typedarray_to_buffer_1 = __importDefault(require(\"typedarray-to-buffer\"));\nconst ENC_HEX = 'hex';\nconst ENC_UTF8 = 'utf8';\nconst ENC_BIN = 'binary';\nconst TYPE_BUFFER = 'buffer';\nconst TYPE_ARRAY = 'array';\nconst TYPE_TYPED_ARRAY = 'typed-array';\nconst TYPE_ARRAY_BUFFER = 'array-buffer';\nconst STRING_ZERO = '0';\nfunction bufferToArray(buf) {\n  return new Uint8Array(buf);\n}\nexports.bufferToArray = bufferToArray;\nfunction bufferToHex(buf) {\n  let prefixed = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n  const hex = buf.toString(ENC_HEX);\n  return prefixed ? addHexPrefix(hex) : hex;\n}\nexports.bufferToHex = bufferToHex;\nfunction bufferToUtf8(buf) {\n  return buf.toString(ENC_UTF8);\n}\nexports.bufferToUtf8 = bufferToUtf8;\nfunction bufferToNumber(buf) {\n  return buf.readUIntBE(0, buf.length);\n}\nexports.bufferToNumber = bufferToNumber;\nfunction bufferToBinary(buf) {\n  return arrayToBinary(bufferToArray(buf));\n}\nexports.bufferToBinary = bufferToBinary;\nfunction arrayToBuffer(arr) {\n  return typedarray_to_buffer_1.default(arr);\n}\nexports.arrayToBuffer = arrayToBuffer;\nfunction arrayToHex(arr) {\n  let prefixed = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n  return bufferToHex(arrayToBuffer(arr), prefixed);\n}\nexports.arrayToHex = arrayToHex;\nfunction arrayToUtf8(arr) {\n  return bufferToUtf8(arrayToBuffer(arr));\n}\nexports.arrayToUtf8 = arrayToUtf8;\nfunction arrayToNumber(arr) {\n  return bufferToNumber(arrayToBuffer(arr));\n}\nexports.arrayToNumber = arrayToNumber;\nfunction arrayToBinary(arr) {\n  return Array.from(arr).map(numberToBinary).join('');\n}\nexports.arrayToBinary = arrayToBinary;\nfunction hexToBuffer(hex) {\n  return Buffer.from(removeHexPrefix(hex), ENC_HEX);\n}\nexports.hexToBuffer = hexToBuffer;\nfunction hexToArray(hex) {\n  return bufferToArray(hexToBuffer(hex));\n}\nexports.hexToArray = hexToArray;\nfunction hexToUtf8(hex) {\n  return bufferToUtf8(hexToBuffer(hex));\n}\nexports.hexToUtf8 = hexToUtf8;\nfunction hexToNumber(hex) {\n  return arrayToNumber(hexToArray(hex));\n}\nexports.hexToNumber = hexToNumber;\nfunction hexToBinary(hex) {\n  return arrayToBinary(hexToArray(hex));\n}\nexports.hexToBinary = hexToBinary;\nfunction utf8ToBuffer(utf8) {\n  return Buffer.from(utf8, ENC_UTF8);\n}\nexports.utf8ToBuffer = utf8ToBuffer;\nfunction utf8ToArray(utf8) {\n  return bufferToArray(utf8ToBuffer(utf8));\n}\nexports.utf8ToArray = utf8ToArray;\nfunction utf8ToHex(utf8) {\n  let prefixed = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n  return bufferToHex(utf8ToBuffer(utf8), prefixed);\n}\nexports.utf8ToHex = utf8ToHex;\nfunction utf8ToNumber(utf8) {\n  const num = parseInt(utf8, 10);\n  assert(isDefined(num), 'Number can only safely store up to 53 bits');\n  return num;\n}\nexports.utf8ToNumber = utf8ToNumber;\nfunction utf8ToBinary(utf8) {\n  return arrayToBinary(utf8ToArray(utf8));\n}\nexports.utf8ToBinary = utf8ToBinary;\nfunction numberToBuffer(num) {\n  return binaryToBuffer(numberToBinary(num));\n}\nexports.numberToBuffer = numberToBuffer;\nfunction numberToArray(num) {\n  return binaryToArray(numberToBinary(num));\n}\nexports.numberToArray = numberToArray;\nfunction numberToHex(num, prefixed) {\n  return binaryToHex(numberToBinary(num), prefixed);\n}\nexports.numberToHex = numberToHex;\nfunction numberToUtf8(num) {\n  return `${num}`;\n}\nexports.numberToUtf8 = numberToUtf8;\nfunction numberToBinary(num) {\n  const bin = (num >>> 0).toString(2);\n  return sanitizeBytes(bin);\n}\nexports.numberToBinary = numberToBinary;\nfunction binaryToBuffer(bin) {\n  return arrayToBuffer(binaryToArray(bin));\n}\nexports.binaryToBuffer = binaryToBuffer;\nfunction binaryToArray(bin) {\n  return new Uint8Array(splitBytes(bin).map(x => parseInt(x, 2)));\n}\nexports.binaryToArray = binaryToArray;\nfunction binaryToHex(bin, prefixed) {\n  return arrayToHex(binaryToArray(bin), prefixed);\n}\nexports.binaryToHex = binaryToHex;\nfunction binaryToUtf8(bin) {\n  return arrayToUtf8(binaryToArray(bin));\n}\nexports.binaryToUtf8 = binaryToUtf8;\nfunction binaryToNumber(bin) {\n  return arrayToNumber(binaryToArray(bin));\n}\nexports.binaryToNumber = binaryToNumber;\nfunction isBinaryString(str) {\n  if (typeof str !== 'string' || !new RegExp(/^[01]+$/).test(str)) {\n    return false;\n  }\n  if (str.length % 8 !== 0) {\n    return false;\n  }\n  return true;\n}\nexports.isBinaryString = isBinaryString;\nfunction isHexString(str, length) {\n  if (typeof str !== 'string' || !str.match(/^0x[0-9A-Fa-f]*$/)) {\n    return false;\n  }\n  if (length && str.length !== 2 + 2 * length) {\n    return false;\n  }\n  return true;\n}\nexports.isHexString = isHexString;\nfunction isBuffer(val) {\n  return Buffer.isBuffer(val);\n}\nexports.isBuffer = isBuffer;\nfunction isTypedArray(val) {\n  return is_typedarray_1.default.strict(val) && !isBuffer(val);\n}\nexports.isTypedArray = isTypedArray;\nfunction isArrayBuffer(val) {\n  return !isTypedArray(val) && !isBuffer(val) && typeof val.byteLength !== 'undefined';\n}\nexports.isArrayBuffer = isArrayBuffer;\nfunction getType(val) {\n  if (isBuffer(val)) {\n    return TYPE_BUFFER;\n  } else if (isTypedArray(val)) {\n    return TYPE_TYPED_ARRAY;\n  } else if (isArrayBuffer(val)) {\n    return TYPE_ARRAY_BUFFER;\n  } else if (Array.isArray(val)) {\n    return TYPE_ARRAY;\n  } else {\n    return typeof val;\n  }\n}\nexports.getType = getType;\nfunction getEncoding(str) {\n  if (isBinaryString(str)) {\n    return ENC_BIN;\n  }\n  if (isHexString(str)) {\n    return ENC_HEX;\n  }\n  return ENC_UTF8;\n}\nexports.getEncoding = getEncoding;\nfunction concatBuffers() {\n  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n    args[_key] = arguments[_key];\n  }\n  const result = Buffer.concat(args);\n  return result;\n}\nexports.concatBuffers = concatBuffers;\nfunction concatArrays() {\n  let result = [];\n  for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n    args[_key2] = arguments[_key2];\n  }\n  args.forEach(arg => result = result.concat(Array.from(arg)));\n  return new Uint8Array([...result]);\n}\nexports.concatArrays = concatArrays;\nfunction trimLeft(data, length) {\n  const diff = data.length - length;\n  if (diff > 0) {\n    data = data.slice(diff);\n  }\n  return data;\n}\nexports.trimLeft = trimLeft;\nfunction trimRight(data, length) {\n  return data.slice(0, length);\n}\nexports.trimRight = trimRight;\nfunction calcByteLength(length) {\n  let byteSize = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 8;\n  const remainder = length % byteSize;\n  return remainder ? (length - remainder) / byteSize * byteSize + byteSize : length;\n}\nexports.calcByteLength = calcByteLength;\nfunction splitBytes(str) {\n  let byteSize = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 8;\n  const bytes = sanitizeBytes(str).match(new RegExp(`.{${byteSize}}`, 'gi'));\n  return Array.from(bytes || []);\n}\nexports.splitBytes = splitBytes;\nfunction swapBytes(str) {\n  return splitBytes(str).map(reverseString).join('');\n}\nexports.swapBytes = swapBytes;\nfunction swapHex(str) {\n  return binaryToHex(swapBytes(hexToBinary(str)));\n}\nexports.swapHex = swapHex;\nfunction sanitizeBytes(str) {\n  let byteSize = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 8;\n  let padding = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : STRING_ZERO;\n  return padLeft(str, calcByteLength(str.length, byteSize), padding);\n}\nexports.sanitizeBytes = sanitizeBytes;\nfunction padLeft(str, length) {\n  let padding = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : STRING_ZERO;\n  return padString(str, length, true, padding);\n}\nexports.padLeft = padLeft;\nfunction padRight(str, length) {\n  let padding = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : STRING_ZERO;\n  return padString(str, length, false, padding);\n}\nexports.padRight = padRight;\nfunction removeHexPrefix(hex) {\n  return hex.replace(/^0x/, '');\n}\nexports.removeHexPrefix = removeHexPrefix;\nfunction addHexPrefix(hex) {\n  return hex.startsWith('0x') ? hex : `0x${hex}`;\n}\nexports.addHexPrefix = addHexPrefix;\nfunction sanitizeHex(hex) {\n  hex = removeHexPrefix(hex);\n  hex = sanitizeBytes(hex, 2);\n  if (hex) {\n    hex = addHexPrefix(hex);\n  }\n  return hex;\n}\nexports.sanitizeHex = sanitizeHex;\nfunction removeHexLeadingZeros(hex) {\n  const prefixed = hex.startsWith('0x');\n  hex = removeHexPrefix(hex);\n  hex = hex.startsWith(STRING_ZERO) ? hex.substring(1) : hex;\n  return prefixed ? addHexPrefix(hex) : hex;\n}\nexports.removeHexLeadingZeros = removeHexLeadingZeros;\nfunction isUndefined(value) {\n  return typeof value === 'undefined';\n}\nfunction isDefined(value) {\n  return !isUndefined(value);\n}\nfunction assert(assertion, errorMessage) {\n  if (!assertion) {\n    throw new Error(errorMessage);\n  }\n}\nfunction reverseString(str) {\n  return str.split('').reverse().join('');\n}\nfunction padString(str, length, left) {\n  let padding = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : STRING_ZERO;\n  const diff = length - str.length;\n  let result = str;\n  if (diff > 0) {\n    const pad = padding.repeat(diff);\n    result = left ? pad + str : str + pad;\n  }\n  return result;\n}","map":{"version":3,"sources":["../../src/index.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst is_typedarray_1 = __importDefault(require(\"is-typedarray\"));\nconst typedarray_to_buffer_1 = __importDefault(require(\"typedarray-to-buffer\"));\nconst ENC_HEX = 'hex';\nconst ENC_UTF8 = 'utf8';\nconst ENC_BIN = 'binary';\nconst TYPE_BUFFER = 'buffer';\nconst TYPE_ARRAY = 'array';\nconst TYPE_TYPED_ARRAY = 'typed-array';\nconst TYPE_ARRAY_BUFFER = 'array-buffer';\nconst STRING_ZERO = '0';\nfunction bufferToArray(buf) {\n    return new Uint8Array(buf);\n}\nexports.bufferToArray = bufferToArray;\nfunction bufferToHex(buf, prefixed = false) {\n    const hex = buf.toString(ENC_HEX);\n    return prefixed ? addHexPrefix(hex) : hex;\n}\nexports.bufferToHex = bufferToHex;\nfunction bufferToUtf8(buf) {\n    return buf.toString(ENC_UTF8);\n}\nexports.bufferToUtf8 = bufferToUtf8;\nfunction bufferToNumber(buf) {\n    return buf.readUIntBE(0, buf.length);\n}\nexports.bufferToNumber = bufferToNumber;\nfunction bufferToBinary(buf) {\n    return arrayToBinary(bufferToArray(buf));\n}\nexports.bufferToBinary = bufferToBinary;\nfunction arrayToBuffer(arr) {\n    return typedarray_to_buffer_1.default(arr);\n}\nexports.arrayToBuffer = arrayToBuffer;\nfunction arrayToHex(arr, prefixed = false) {\n    return bufferToHex(arrayToBuffer(arr), prefixed);\n}\nexports.arrayToHex = arrayToHex;\nfunction arrayToUtf8(arr) {\n    return bufferToUtf8(arrayToBuffer(arr));\n}\nexports.arrayToUtf8 = arrayToUtf8;\nfunction arrayToNumber(arr) {\n    return bufferToNumber(arrayToBuffer(arr));\n}\nexports.arrayToNumber = arrayToNumber;\nfunction arrayToBinary(arr) {\n    return Array.from(arr)\n        .map(numberToBinary)\n        .join('');\n}\nexports.arrayToBinary = arrayToBinary;\nfunction hexToBuffer(hex) {\n    return Buffer.from(removeHexPrefix(hex), ENC_HEX);\n}\nexports.hexToBuffer = hexToBuffer;\nfunction hexToArray(hex) {\n    return bufferToArray(hexToBuffer(hex));\n}\nexports.hexToArray = hexToArray;\nfunction hexToUtf8(hex) {\n    return bufferToUtf8(hexToBuffer(hex));\n}\nexports.hexToUtf8 = hexToUtf8;\nfunction hexToNumber(hex) {\n    return arrayToNumber(hexToArray(hex));\n}\nexports.hexToNumber = hexToNumber;\nfunction hexToBinary(hex) {\n    return arrayToBinary(hexToArray(hex));\n}\nexports.hexToBinary = hexToBinary;\nfunction utf8ToBuffer(utf8) {\n    return Buffer.from(utf8, ENC_UTF8);\n}\nexports.utf8ToBuffer = utf8ToBuffer;\nfunction utf8ToArray(utf8) {\n    return bufferToArray(utf8ToBuffer(utf8));\n}\nexports.utf8ToArray = utf8ToArray;\nfunction utf8ToHex(utf8, prefixed = false) {\n    return bufferToHex(utf8ToBuffer(utf8), prefixed);\n}\nexports.utf8ToHex = utf8ToHex;\nfunction utf8ToNumber(utf8) {\n    const num = parseInt(utf8, 10);\n    assert(isDefined(num), 'Number can only safely store up to 53 bits');\n    return num;\n}\nexports.utf8ToNumber = utf8ToNumber;\nfunction utf8ToBinary(utf8) {\n    return arrayToBinary(utf8ToArray(utf8));\n}\nexports.utf8ToBinary = utf8ToBinary;\nfunction numberToBuffer(num) {\n    return binaryToBuffer(numberToBinary(num));\n}\nexports.numberToBuffer = numberToBuffer;\nfunction numberToArray(num) {\n    return binaryToArray(numberToBinary(num));\n}\nexports.numberToArray = numberToArray;\nfunction numberToHex(num, prefixed) {\n    return binaryToHex(numberToBinary(num), prefixed);\n}\nexports.numberToHex = numberToHex;\nfunction numberToUtf8(num) {\n    return `${num}`;\n}\nexports.numberToUtf8 = numberToUtf8;\nfunction numberToBinary(num) {\n    const bin = (num >>> 0).toString(2);\n    return sanitizeBytes(bin);\n}\nexports.numberToBinary = numberToBinary;\nfunction binaryToBuffer(bin) {\n    return arrayToBuffer(binaryToArray(bin));\n}\nexports.binaryToBuffer = binaryToBuffer;\nfunction binaryToArray(bin) {\n    return new Uint8Array(splitBytes(bin).map(x => parseInt(x, 2)));\n}\nexports.binaryToArray = binaryToArray;\nfunction binaryToHex(bin, prefixed) {\n    return arrayToHex(binaryToArray(bin), prefixed);\n}\nexports.binaryToHex = binaryToHex;\nfunction binaryToUtf8(bin) {\n    return arrayToUtf8(binaryToArray(bin));\n}\nexports.binaryToUtf8 = binaryToUtf8;\nfunction binaryToNumber(bin) {\n    return arrayToNumber(binaryToArray(bin));\n}\nexports.binaryToNumber = binaryToNumber;\nfunction isBinaryString(str) {\n    if (typeof str !== 'string' || !new RegExp(/^[01]+$/).test(str)) {\n        return false;\n    }\n    if (str.length % 8 !== 0) {\n        return false;\n    }\n    return true;\n}\nexports.isBinaryString = isBinaryString;\nfunction isHexString(str, length) {\n    if (typeof str !== 'string' || !str.match(/^0x[0-9A-Fa-f]*$/)) {\n        return false;\n    }\n    if (length && str.length !== 2 + 2 * length) {\n        return false;\n    }\n    return true;\n}\nexports.isHexString = isHexString;\nfunction isBuffer(val) {\n    return Buffer.isBuffer(val);\n}\nexports.isBuffer = isBuffer;\nfunction isTypedArray(val) {\n    return is_typedarray_1.default.strict(val) && !isBuffer(val);\n}\nexports.isTypedArray = isTypedArray;\nfunction isArrayBuffer(val) {\n    return (!isTypedArray(val) &&\n        !isBuffer(val) &&\n        typeof val.byteLength !== 'undefined');\n}\nexports.isArrayBuffer = isArrayBuffer;\nfunction getType(val) {\n    if (isBuffer(val)) {\n        return TYPE_BUFFER;\n    }\n    else if (isTypedArray(val)) {\n        return TYPE_TYPED_ARRAY;\n    }\n    else if (isArrayBuffer(val)) {\n        return TYPE_ARRAY_BUFFER;\n    }\n    else if (Array.isArray(val)) {\n        return TYPE_ARRAY;\n    }\n    else {\n        return typeof val;\n    }\n}\nexports.getType = getType;\nfunction getEncoding(str) {\n    if (isBinaryString(str)) {\n        return ENC_BIN;\n    }\n    if (isHexString(str)) {\n        return ENC_HEX;\n    }\n    return ENC_UTF8;\n}\nexports.getEncoding = getEncoding;\nfunction concatBuffers(...args) {\n    const result = Buffer.concat(args);\n    return result;\n}\nexports.concatBuffers = concatBuffers;\nfunction concatArrays(...args) {\n    let result = [];\n    args.forEach(arg => (result = result.concat(Array.from(arg))));\n    return new Uint8Array([...result]);\n}\nexports.concatArrays = concatArrays;\nfunction trimLeft(data, length) {\n    const diff = data.length - length;\n    if (diff > 0) {\n        data = data.slice(diff);\n    }\n    return data;\n}\nexports.trimLeft = trimLeft;\nfunction trimRight(data, length) {\n    return data.slice(0, length);\n}\nexports.trimRight = trimRight;\nfunction calcByteLength(length, byteSize = 8) {\n    const remainder = length % byteSize;\n    return remainder\n        ? ((length - remainder) / byteSize) * byteSize + byteSize\n        : length;\n}\nexports.calcByteLength = calcByteLength;\nfunction splitBytes(str, byteSize = 8) {\n    const bytes = sanitizeBytes(str).match(new RegExp(`.{${byteSize}}`, 'gi'));\n    return Array.from(bytes || []);\n}\nexports.splitBytes = splitBytes;\nfunction swapBytes(str) {\n    return splitBytes(str)\n        .map(reverseString)\n        .join('');\n}\nexports.swapBytes = swapBytes;\nfunction swapHex(str) {\n    return binaryToHex(swapBytes(hexToBinary(str)));\n}\nexports.swapHex = swapHex;\nfunction sanitizeBytes(str, byteSize = 8, padding = STRING_ZERO) {\n    return padLeft(str, calcByteLength(str.length, byteSize), padding);\n}\nexports.sanitizeBytes = sanitizeBytes;\nfunction padLeft(str, length, padding = STRING_ZERO) {\n    return padString(str, length, true, padding);\n}\nexports.padLeft = padLeft;\nfunction padRight(str, length, padding = STRING_ZERO) {\n    return padString(str, length, false, padding);\n}\nexports.padRight = padRight;\nfunction removeHexPrefix(hex) {\n    return hex.replace(/^0x/, '');\n}\nexports.removeHexPrefix = removeHexPrefix;\nfunction addHexPrefix(hex) {\n    return hex.startsWith('0x') ? hex : `0x${hex}`;\n}\nexports.addHexPrefix = addHexPrefix;\nfunction sanitizeHex(hex) {\n    hex = removeHexPrefix(hex);\n    hex = sanitizeBytes(hex, 2);\n    if (hex) {\n        hex = addHexPrefix(hex);\n    }\n    return hex;\n}\nexports.sanitizeHex = sanitizeHex;\nfunction removeHexLeadingZeros(hex) {\n    const prefixed = hex.startsWith('0x');\n    hex = removeHexPrefix(hex);\n    hex = hex.startsWith(STRING_ZERO) ? hex.substring(1) : hex;\n    return prefixed ? addHexPrefix(hex) : hex;\n}\nexports.removeHexLeadingZeros = removeHexLeadingZeros;\nfunction isUndefined(value) {\n    return typeof value === 'undefined';\n}\nfunction isDefined(value) {\n    return !isUndefined(value);\n}\nfunction assert(assertion, errorMessage) {\n    if (!assertion) {\n        throw new Error(errorMessage);\n    }\n}\nfunction reverseString(str) {\n    return str\n        .split('')\n        .reverse()\n        .join('');\n}\nfunction padString(str, length, left, padding = STRING_ZERO) {\n    const diff = length - str.length;\n    let result = str;\n    if (diff > 0) {\n        const pad = padding.repeat(diff);\n        result = left ? pad + str : str + pad;\n    }\n    return result;\n}\n//# sourceMappingURL=index.js.map"]},"metadata":{},"sourceType":"script"}