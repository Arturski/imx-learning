{"ast":null,"code":"import * as t from 'io-ts';\nvar leftLiteral = t.literal('Left');\nvar rightLiteral = t.literal('Right');\n/**\n * Given a codec representing a type `L` and a codec representing a type `A`, returns a codec representing `Either<L, A>` that is able to deserialize\n * the JSON representation of an `Either`.\n *\n * @example\n * import { either } from 'io-ts-types/es6/either'\n * import { left, right } from 'fp-ts/es6/Either'\n * import * as t from 'io-ts'\n * import { PathReporter } from 'io-ts/es6/PathReporter'\n *\n * const T = either(t.string, t.number)\n *\n * assert.deepStrictEqual(T.decode(right(1)), right(right(1)))\n * assert.deepStrictEqual(T.decode(left('a')), right(left('a')))\n * assert.deepStrictEqual(PathReporter.report(T.decode(right('a'))), ['Invalid value \"a\" supplied to : Either<string, number>/1: Right<string>/right: number'])\n *\n * @since 0.5.0\n */\nexport function either(leftCodec, rightCodec, name) {\n  if (name === void 0) {\n    name = \"Either<\" + leftCodec.name + \", \" + rightCodec.name + \">\";\n  }\n  return t.union([t.strict({\n    _tag: leftLiteral,\n    left: leftCodec\n  }, \"Left<\" + leftCodec.name + \">\"), t.strict({\n    _tag: rightLiteral,\n    right: rightCodec\n  }, \"Right<\" + leftCodec.name + \">\")], name);\n}","map":{"version":3,"names":["t","leftLiteral","literal","rightLiteral","either","leftCodec","rightCodec","name","union","strict","_tag","left","right"],"sources":["/Users/arthurfrancis/Documents/repo/imx-reactjs-integration-example/node_modules/io-ts-types/es6/either.js"],"sourcesContent":["import * as t from 'io-ts';\nvar leftLiteral = t.literal('Left');\nvar rightLiteral = t.literal('Right');\n/**\n * Given a codec representing a type `L` and a codec representing a type `A`, returns a codec representing `Either<L, A>` that is able to deserialize\n * the JSON representation of an `Either`.\n *\n * @example\n * import { either } from 'io-ts-types/es6/either'\n * import { left, right } from 'fp-ts/es6/Either'\n * import * as t from 'io-ts'\n * import { PathReporter } from 'io-ts/es6/PathReporter'\n *\n * const T = either(t.string, t.number)\n *\n * assert.deepStrictEqual(T.decode(right(1)), right(right(1)))\n * assert.deepStrictEqual(T.decode(left('a')), right(left('a')))\n * assert.deepStrictEqual(PathReporter.report(T.decode(right('a'))), ['Invalid value \"a\" supplied to : Either<string, number>/1: Right<string>/right: number'])\n *\n * @since 0.5.0\n */\nexport function either(leftCodec, rightCodec, name) {\n    if (name === void 0) { name = \"Either<\" + leftCodec.name + \", \" + rightCodec.name + \">\"; }\n    return t.union([\n        t.strict({\n            _tag: leftLiteral,\n            left: leftCodec\n        }, \"Left<\" + leftCodec.name + \">\"),\n        t.strict({\n            _tag: rightLiteral,\n            right: rightCodec\n        }, \"Right<\" + leftCodec.name + \">\")\n    ], name);\n}\n"],"mappings":"AAAA,OAAO,KAAKA,CAAC,MAAM,OAAO;AAC1B,IAAIC,WAAW,GAAGD,CAAC,CAACE,OAAO,CAAC,MAAM,CAAC;AACnC,IAAIC,YAAY,GAAGH,CAAC,CAACE,OAAO,CAAC,OAAO,CAAC;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASE,MAAM,CAACC,SAAS,EAAEC,UAAU,EAAEC,IAAI,EAAE;EAChD,IAAIA,IAAI,KAAK,KAAK,CAAC,EAAE;IAAEA,IAAI,GAAG,SAAS,GAAGF,SAAS,CAACE,IAAI,GAAG,IAAI,GAAGD,UAAU,CAACC,IAAI,GAAG,GAAG;EAAE;EACzF,OAAOP,CAAC,CAACQ,KAAK,CAAC,CACXR,CAAC,CAACS,MAAM,CAAC;IACLC,IAAI,EAAET,WAAW;IACjBU,IAAI,EAAEN;EACV,CAAC,EAAE,OAAO,GAAGA,SAAS,CAACE,IAAI,GAAG,GAAG,CAAC,EAClCP,CAAC,CAACS,MAAM,CAAC;IACLC,IAAI,EAAEP,YAAY;IAClBS,KAAK,EAAEN;EACX,CAAC,EAAE,QAAQ,GAAGD,SAAS,CAACE,IAAI,GAAG,GAAG,CAAC,CACtC,EAAEA,IAAI,CAAC;AACZ"},"metadata":{},"sourceType":"module"}